{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to trace-shrink","text":"<p><code>trace-shrink</code> is a python package that allows you to analyze captures of HTTP traffic, from HAR files, Proxyman logs, Bodylogger files, or multifile archives. Its main focus is on providing a base to analyze recorded ABR streams (HLS and MPEG-DASH), in particular live streams in which the same URL to the manifest is GET-ed multiple times.</p>"},{"location":"#traces","title":"Traces?","text":"<p>Archives, captures, logs, traces, etc. are all essentially variations of the same thing. They are all files that contain HTTP traffic.  In this tool, I use the term \"trace\" to refer to any of these files.</p> <p>Currently, the tool supports the following trace file formats:</p> <ul> <li>.har (typically from Chrome DevTools)</li> <li>.proxymanlogv2 (generated by the excellent Proxyman)</li> <li>.log (bodylogger format - read-only)</li> <li>multifile archives:</li> <li>Directory-based (folder containing request_.meta.json and request_.body files)</li> <li>Archive-based: .barc or .zip files containing the same structure</li> <li>Files can be in the root folder or in a <code>requests/</code> subdirectory</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Unified API regardless of the type of trace file</li> <li>Detect ABR manifest URLs from HAR files, Proxyman logs, or Bodylogger files</li> <li>Extract a stream of requests to a single ABR manifest URL</li> <li>Convert between formats (e.g., bodylogger to HAR)</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install trace-shrink\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>See the usage page for more details.</p>"},{"location":"#beyond-trace-shrink","title":"Beyond trace-shrink","text":"<p>This package is limited to working with trace files, with a grasp of what requests within it are related to an ABR streaming session.</p> <p>Having extracted the relevant requests, you can then use other tools to analyze the stream. What tool you then use it up to you. Some recommendations (from my personal experience) are:</p> <ul> <li>m3u8 to parse and analyze HLS streams</li> <li>mpd-inspector to parse and analyze MPEG-DASH streams (yes, it's another of my projects)</li> </ul> <p>Other tools that are built on top of trace-shrink:</p> <ul> <li>abr-encore creates a server for replaying the ABR stream contained in the trace file almost like it was when captured. It's a great way to test any client or manifest manipulator in a controlled environment.</li> </ul>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#entries","title":"Entries","text":"<ul> <li>See the dedicated reference page: Entries API</li> </ul>"},{"location":"api/#readers","title":"Readers","text":"<ul> <li>See the dedicated reference page: Readers API</li> </ul>"},{"location":"api/#writers","title":"Writers","text":"<ul> <li>See the dedicated reference page: Writers API</li> </ul>"},{"location":"usage/","title":"Usage Guide","text":"<p>This guide provides a quick overview of how to use <code>trace-shrink</code> to analyze your network capture files.</p>"},{"location":"usage/#opening-an-archive","title":"Opening an Archive","text":"<p>The main entry point to the library is the <code>open_trace</code> function. It automatically detects the file type (HAR, Proxyman, Bodylogger, or multifile directory) and returns a <code>Trace</code> object. The appropriate reader is used internally to load the file, but you work directly with the <code>Trace</code> object.</p> <pre><code>from trace_shrink import open_trace\n\ntry:\n    # Open a HAR file\n    har_trace = open_trace(\"path/to/your/capture.har\")\n\n    # Or open a Proxyman log\n    proxyman_trace = open_trace(\"path/to/your/capture.proxymanlogv2\")\n\n    # Or open a Bodylogger file\n    bodylogger_trace = open_trace(\"path/to/your/capture.log\")\n\n    # Or open a multifile directory archive\n    multifile_trace = open_trace(\"path/to/your/capture_folder\")\n\n    # Or open a .barc/.zip archive containing multifile format\n    archive_trace = open_trace(\"path/to/your/capture.barc\")\n\n    print(f\"Successfully opened trace with {len(har_trace)} entries.\")\n\nexcept FileNotFoundError:\n    print(\"Error: The file was not found.\")\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n</code></pre> <p>Note: Bodylogger files (.log) are read-only. You cannot modify or save changes to them.</p>"},{"location":"usage/#iterating-and-filtering-entries","title":"Iterating and Filtering Entries","text":"<p>Once you have a <code>Trace</code> object, you can iterate over its <code>TraceEntry</code> objects or use the built-in methods to filter them.</p>"},{"location":"usage/#basic-iteration","title":"Basic Iteration","text":"<pre><code>from trace_shrink import open_trace\n\ntrace = open_trace(\"path/to/your/capture.har\")\n\nfor entry in trace:\n    print(f\"[{entry.index}] {entry.request.method} {entry.request.url} -&gt; {entry.response.status_code}\")\n</code></pre>"},{"location":"usage/#filtering","title":"Filtering","text":"<p>The <code>Trace</code> class provides multiple filtering methods:</p> <pre><code>from trace_shrink import open_trace\n\ntrace = open_trace(\"path/to/your/capture.har\")\n\n# General filter method - combine multiple criteria\napi_calls = trace.filter(host=\"api.example.com\", mime_type=\"application/json\")\nprint(f\"Found {len(api_calls)} JSON API calls\")\n\n# Filter by host\nhost_entries = trace.get_entries_by_host(\"example.com\")\n\n# Filter by exact URL\nurl_entries = trace.get_entries_for_url(\"https://example.com/manifest.mpd\")\n\n# Filter by URL path\npath_entries = trace.get_entries_by_path(\"/api/v1/data\")\n\n# Filter by partial URL (substring or regex pattern)\npartial_entries = trace.get_entries_for_partial_url(\"manifest\")\n\n# Get specific entry by ID\nentry = trace.get_entry_by_id(\"entry-123\")\n\n# Get multiple entries by IDs\nentries = trace.get_entries_by_ids([\"entry-1\", \"entry-2\", \"entry-3\"])\n\n# Navigate to next/previous entry in a manifest stream\nnext_entry = trace.get_next_entry_by_id(\"entry-123\", direction=1, n=1)  # Next\nprev_entry = trace.get_next_entry_by_id(\"entry-123\", direction=-1, n=1)  # Previous\n</code></pre>"},{"location":"usage/#working-with-abr-streams","title":"Working with ABR Streams","text":"<p><code>trace-shrink</code> provides high-level APIs to simplify working with Adaptive Bitrate (ABR) streams like HLS and DASH.</p>"},{"location":"usage/#finding-manifest-urls","title":"Finding Manifest URLs","text":"<p>You can automatically detect all ABR manifest URLs within a capture using the <code>get_abr_manifest_urls</code> method. This is more reliable than filtering by MIME type alone as it also inspects URLs.</p> <pre><code>from trace_shrink import open_trace, Format\n\ntrace = open_trace(\"path/to/your/capture.har\")\n\n# Get all ABR manifest URLs (HLS &amp; DASH)\nmanifest_urls = trace.get_abr_manifest_urls()\n\nprint(\"Found ABR Manifests:\")\nfor decorated_url in manifest_urls:\n    print(f\"- URL: {decorated_url.url}\")\n    print(f\"  Format: {decorated_url.format}\")\n\n# You can also filter by a specific format (using string or Format enum)\nhls_urls = trace.get_abr_manifest_urls(format=\"hls\")\n# Or using Format enum:\n# hls_urls = trace.get_abr_manifest_urls(format=Format.HLS)\nprint(f\"\\\\nFound {len(hls_urls)} HLS manifest(s).\")\n</code></pre>"},{"location":"usage/#manifeststream","title":"ManifestStream","text":"<p>A <code>ManifestStream</code> represents the sequence of requests made to a single manifest URL in chronological order (for example, repeated GETs of the same HLS playlist). It is useful to analyze manifest refreshes, compare versions over time, and navigate entries by time or position.</p> <p>You can get a <code>ManifestStream</code> from a <code>Trace</code> by passing a manifest URL (as <code>yarl.URL</code> or string) to <code>get_manifest_stream()</code>.</p> <pre><code>from trace_shrink import open_trace\n\ntrace = open_trace(\"path/to/your/capture.har\")\nmanifest_urls = trace.get_abr_manifest_urls()\n\nif manifest_urls:\n    # Use the first detected manifest URL\n    manifest_stream = trace.get_manifest_stream(manifest_urls[0].url)\n    print(f\"Manifest stream contains {len(manifest_stream)} entries\")\n    # Iterate chronological entries\n    for entry in manifest_stream:\n        print(entry.timeline.request_start, entry.response.status_code)\n\n    # Find entry near a given time\n    from datetime import datetime, timezone\n    target = datetime(2026, 1, 15, 12, 0, 0, tzinfo=timezone.utc)\n    found = manifest_stream.find_entry_by_time(target, position=\"nearest\", tolerance=2.0)\n    if found:\n        print(\"Closest entry at\", found.timeline.request_start)\n</code></pre>"},{"location":"usage/#advanced-manifeststream-operations","title":"Advanced ManifestStream Operations","text":"<p>The <code>ManifestStream</code> class provides additional methods for time-based navigation:</p> <pre><code>from datetime import datetime, timezone, timedelta\n\n# Find entry by time with tolerance\ntarget_time = datetime(2026, 1, 15, 12, 30, 0, tzinfo=timezone.utc)\nentry = manifest_stream.find_entry_by_time(\n    target_time,\n    position=\"nearest\",  # or \"before\", \"after\"\n    tolerance=5.0  # seconds\n)\n\n# Navigate relative to a specific entry\ncurrent_entry = manifest_stream.entries[5]\nnext_entry = manifest_stream.get_relative_entry(current_entry, direction=1, n=1)  # Next entry\nprevious_entry = manifest_stream.get_relative_entry(current_entry, direction=-1, n=1)  # Previous\nthird_next = manifest_stream.get_relative_entry(current_entry, direction=1, n=3)  # Skip ahead 3\n\n# Get the original path of the manifest\nmanifest_path = manifest_stream.get_original_path()\n</code></pre>"},{"location":"usage/#configuring-abr-detection","title":"Configuring ABR Detection","text":"<p>You can define what entries are considered to be containing manifests and/or part of a manifest stream, by configuring the ABR detector.</p>"},{"location":"usage/#ignore-query-parameters","title":"Ignore query parameters","text":"<p>If there is a query parameter that appears on some URLs that look like manifest URLs but are not (eg. sidecar files), you can customize which query parameters to ignore:</p> <pre><code>from trace_shrink import open_trace\n\n# Open the trace and configure the ABR detector to ignore specific query params\ntrace = open_trace(\"path/to/your/capture.har\")\n\n# Treat URLs that do not contain specific query params\ntrace.abr_detector.ignore_query_params([\"bk-ml\", \"token\"])  # method chains and accepts a string or list\n\n# Now retrieve deduplicated manifest URLs\nmanifest_urls = trace.get_abr_manifest_urls()\nfor d in manifest_urls:\n    print(d.url, d.format)\n\n# You can then extract a ManifestStream for a chosen manifest URL as usual:\nmanifest_stream = trace.get_manifest_stream(manifest_urls[0].url)\n</code></pre>"},{"location":"usage/#converting-exporting","title":"Converting / Exporting","text":"<p>You can export entries from a <code>Trace</code> to supported archive formats. The <code>Exporter</code> class provides convenient instance and class methods for exporting to different formats, in particular HAR or Proxyman Logs v2. </p> <p>Use the instance API when you have a <code>Trace</code>, or the class methods when you already have a list of <code>TraceEntry</code> objects.</p> <pre><code>from trace_shrink import open_trace, Exporter\n\n# Open any trace file\ntrace = open_trace(\"path/to/capture.log\")\n\n# Create an exporter and convert to HAR\nexporter = Exporter(trace)\nexporter.to_har(\"output.har\")\n\n# Or convert to Proxyman format\nexporter.to_proxyman(\"output.proxymanlogv2\")\n\nprint(f\"Converted {len(trace)} entries.\")\n</code></pre> <p>You can also use the <code>Exporter</code> as a class method with specific entries:</p> <pre><code>from trace_shrink import open_trace, Exporter\n\ntrace = open_trace(\"path/to/capture.har\")\n\n# Export only specific entries\nfiltered_entries = trace.filter(host=\"api.example.com\")\nExporter.to_har(\"filtered.har\", filtered_entries)\n</code></pre> <p>You can also export to the directory-based multifile format:</p> <pre><code>from trace_shrink import open_trace, Exporter\n\ntrace = open_trace(\"path/to/capture.har\")\nExporter(trace).to_multifile(\"output_folder\")\n\n# Or as a class method when you already have a list of entries:\nExporter.to_multifile(\"output_folder\", trace.entries)\n</code></pre> <p>Note: The multifile format creates files in a folder structure. Files can be at the root level or within a <code>requests/</code> subdirectory. You can then archive this folder as a .barc or .zip file for easier distribution while maintaining compatibility with the reader.</p> <p>This covers the most common use cases for getting started with <code>trace-shrink</code>. For a detailed list of all available classes and methods, please see the API Reference. </p>"},{"location":"api/entries/","title":"Entries","text":""},{"location":"api/entries/#trace_shrinkentries","title":"trace_shrink.entries","text":"<p>This page documents the public entry types available under <code>trace_shrink.entries</code>.</p> <p>Main exports</p> <ul> <li><code>TraceEntry</code>: abstract base for trace entries.</li> <li><code>RequestDetails</code>: request metadata container (url, method, headers).</li> <li><code>ResponseDetails</code>: response metadata container (status_code, headers, mime_type).</li> <li><code>ResponseBodyDetails</code>: body-specific details (raw_size, compressed_size, text).</li> <li><code>TimelineDetails</code>: timing information for requests/responses.</li> </ul> <p>Concrete entry implementations</p> <ul> <li><code>HarEntry</code>: entry parsed from HAR files.</li> <li><code>MultiFileTraceEntry</code>: entry loaded from multifile archives (meta.json + body files).</li> <li><code>ProxymanLogV2Entry</code>: entry parsed from Proxyman Log v2 format.</li> <li><code>BodyLoggerEntry</code>: entry parsed from BodyLogger format.</li> <li><code>RequestsResponseTraceEntry</code>: adapter for the <code>requests</code> library response objects.</li> </ul> <p>Autogenerated API docs (from code)</p> <p>Include specific members:</p>"},{"location":"api/entries/#trace_shrink.entries","title":"trace_shrink.entries","text":"<p>Entry types exposed by trace_shrink.entries</p> <p>This module re-exports the main TraceEntry implementations so users can <code>from trace_shrink.entries import TraceEntry, HarEntry, MultiFileTraceEntry</code>.</p>"},{"location":"api/entries/#trace_shrink.entries-classes","title":"Classes","text":""},{"location":"api/entries/#trace_shrink.entries.BodyLoggerEntry","title":"BodyLoggerEntry","text":"<pre><code>BodyLoggerEntry(\n    index: int,\n    entry_id: str,\n    request: RequestDetails,\n    response: ResponseDetails,\n    timeline: TimelineDetails,\n    comment: Optional[str] = None,\n    highlight: Optional[str] = None,\n    annotations: Optional[Dict[str, str]] = None,\n)\n</code></pre> <p>               Bases: <code>TraceEntry</code></p> <p>Represents a single entry from a bodylogger file.</p> <p>This is a TraceEntry with bodylogger-specific properties for backward compatibility.</p>"},{"location":"api/entries/#trace_shrink.entries.BodyLoggerEntry-attributes","title":"Attributes","text":"index \u00b6 <pre><code>index: int\n</code></pre> <p>The zero-based index of the entry in the archive.</p> <code></code> id \u00b6 <pre><code>id: str\n</code></pre> <p>A unique identifier for the entry.</p> <code></code> request \u00b6 <pre><code>request: RequestDetails\n</code></pre> <p>Details of the HTTP request, with merged override headers.</p> <code></code> response \u00b6 <pre><code>response: ResponseDetails\n</code></pre> <p>Details of the HTTP response, with merged override headers.</p> <code></code> timeline \u00b6 <pre><code>timeline: TimelineDetails\n</code></pre> <p>Timeline details of the HTTP exchange.</p> <code></code> comment \u00b6 <pre><code>comment: Optional[str]\n</code></pre> <p>An optional comment for the entry.</p> <code></code> highlight \u00b6 <pre><code>highlight: Optional[str]\n</code></pre> <p>An optional highlight style for the entry (e.g., 'red', 'yellow', 'strike').</p> <code></code> annotations \u00b6 <pre><code>annotations: Dict[str, str]\n</code></pre> <p>Return annotations dict, merging overrides with original annotations.</p> <p>Filters out None values (which represent removed annotations).</p> <code></code> content \u00b6 <pre><code>content: bytes | str\n</code></pre> <p>The content of the entry, extracted from the response body.</p> <code></code> content_bytes \u00b6 <pre><code>content_bytes: bytes\n</code></pre> <p>The content of the entry as bytes, converting strings if necessary.</p> <code></code> format \u00b6 <pre><code>format: Optional[Format]\n</code></pre> <p>The format of the entry (HLS, DASH, or None), determined from content type or URL.</p> <code></code> service_id \u00b6 <pre><code>service_id: Optional[str]\n</code></pre> <p>Return the service ID for this entry.</p> <code></code> session_id \u00b6 <pre><code>session_id: Optional[str]\n</code></pre> <p>Return the session ID for this entry.</p> <code></code> correlation_id \u00b6 <pre><code>correlation_id: int\n</code></pre> <p>Return the correlation ID for this entry.</p>"},{"location":"api/entries/#trace_shrink.entries.BodyLoggerEntry-functions","title":"Functions","text":"set_comment \u00b6 <pre><code>set_comment(comment: str) -&gt; None\n</code></pre> <p>Set a comment on this entry.</p> <code></code> set_highlight \u00b6 <pre><code>set_highlight(highlight: str) -&gt; None\n</code></pre> <p>Set a highlight style on this entry.</p> <p>Supported values: - \"red\" (0) - \"yellow\" (1) - \"green\" (2) - \"blue\" (3) - \"purple\" (4) - \"grey\" (5) - \"strike\" (strike-through)</p> <p>Parameters:</p> Name Type Description Default <code>highlight</code> <code>str</code> <p>The highlight style to apply.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid highlight value is provided.</p> <code></code> add_request_header \u00b6 <pre><code>add_request_header(name: str, value: str) -&gt; None\n</code></pre> <p>Add or update a header in the request.</p> <code></code> add_response_header \u00b6 <pre><code>add_response_header(name: str, value: str) -&gt; None\n</code></pre> <p>Add or update a header in the response.</p> <code></code> set_response_content \u00b6 <pre><code>set_response_content(content: str) -&gt; None\n</code></pre> <p>Set the response body content.</p> <code></code> add_annotation \u00b6 <pre><code>add_annotation(annotation_type: str, content: str) -&gt; None\n</code></pre> <p>Add or update an annotation.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_type</code> <code>str</code> <p>The type/key of the annotation (e.g., \"digest\", \"dash-preview\")</p> required <code>content</code> <code>str</code> <p>The annotation content/value</p> required <code></code> remove_annotation \u00b6 <pre><code>remove_annotation(annotation_type: str) -&gt; None\n</code></pre> <p>Remove an annotation.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_type</code> <code>str</code> <p>The type/key of the annotation to remove</p> required <code></code> get_raw_data \u00b6 <pre><code>get_raw_data() -&gt; Dict[str, Any]\n</code></pre> <p>Returns the raw data for this entry.</p>"},{"location":"api/entries/#trace_shrink.entries.HarEntry","title":"HarEntry","text":"<pre><code>HarEntry(har_entry_data: Dict[str, Any], reader: Any, entry_index: int)\n</code></pre> <p>               Bases: <code>TraceEntry</code></p> <p>Represents a single entry in a HAR file, providing access to request, response, and timeline details.</p> <p>Parameters:</p> Name Type Description Default <code>har_entry_data</code> <code>Dict[str, Any]</code> <p>The raw dictionary for the HAR entry.</p> required <code>reader</code> <code>Any</code> <p>The HarReader instance that this entry belongs to.</p> required <code>entry_index</code> <code>int</code> <p>The index of this entry within the HAR file.</p> required"},{"location":"api/entries/#trace_shrink.entries.HarEntry-attributes","title":"Attributes","text":"index \u00b6 <pre><code>index: int\n</code></pre> <p>The zero-based index of the entry in the archive.</p> <code></code> id \u00b6 <pre><code>id: str\n</code></pre> <p>A unique identifier for the entry.</p> <code></code> request \u00b6 <pre><code>request: RequestDetails\n</code></pre> <p>Details of the HTTP request, with merged override headers.</p> <code></code> response \u00b6 <pre><code>response: ResponseDetails\n</code></pre> <p>Details of the HTTP response, with merged override headers.</p> <code></code> timeline \u00b6 <pre><code>timeline: TimelineDetails\n</code></pre> <p>Timeline details of the HTTP exchange.</p> <code></code> comment \u00b6 <pre><code>comment: Optional[str]\n</code></pre> <p>An optional comment for the entry.</p> <code></code> highlight \u00b6 <pre><code>highlight: Optional[str]\n</code></pre> <p>An optional highlight style for the entry (e.g., 'red', 'yellow', 'strike').</p> <code></code> annotations \u00b6 <pre><code>annotations: Dict[str, str]\n</code></pre> <p>Return annotations dict, merging overrides with original annotations.</p> <p>Filters out None values (which represent removed annotations).</p> <code></code> content \u00b6 <pre><code>content: bytes | str\n</code></pre> <p>The content of the entry, extracted from the response body.</p> <code></code> content_bytes \u00b6 <pre><code>content_bytes: bytes\n</code></pre> <p>The content of the entry as bytes, converting strings if necessary.</p> <code></code> format \u00b6 <pre><code>format: Optional[Format]\n</code></pre> <p>The format of the entry (HLS, DASH, or None), determined from content type or URL.</p> <code></code> time \u00b6 <pre><code>time: Optional[float]\n</code></pre> <p>Total time for the entry in milliseconds from the HAR spec.</p>"},{"location":"api/entries/#trace_shrink.entries.HarEntry-functions","title":"Functions","text":"set_comment \u00b6 <pre><code>set_comment(comment: str) -&gt; None\n</code></pre> <p>Set a comment on this entry.</p> <code></code> set_highlight \u00b6 <pre><code>set_highlight(highlight: str) -&gt; None\n</code></pre> <p>Set a highlight style on this entry.</p> <p>Supported values: - \"red\" (0) - \"yellow\" (1) - \"green\" (2) - \"blue\" (3) - \"purple\" (4) - \"grey\" (5) - \"strike\" (strike-through)</p> <p>Parameters:</p> Name Type Description Default <code>highlight</code> <code>str</code> <p>The highlight style to apply.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid highlight value is provided.</p> <code></code> add_request_header \u00b6 <pre><code>add_request_header(name: str, value: str) -&gt; None\n</code></pre> <p>Add or update a header in the request.</p> <code></code> add_response_header \u00b6 <pre><code>add_response_header(name: str, value: str) -&gt; None\n</code></pre> <p>Add or update a header in the response.</p> <code></code> set_response_content \u00b6 <pre><code>set_response_content(content: str) -&gt; None\n</code></pre> <p>Set the response body content.</p> <code></code> add_annotation \u00b6 <pre><code>add_annotation(annotation_type: str, content: str) -&gt; None\n</code></pre> <p>Add or update an annotation.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_type</code> <code>str</code> <p>The type/key of the annotation (e.g., \"digest\", \"dash-preview\")</p> required <code>content</code> <code>str</code> <p>The annotation content/value</p> required <code></code> remove_annotation \u00b6 <pre><code>remove_annotation(annotation_type: str) -&gt; None\n</code></pre> <p>Remove an annotation.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_type</code> <code>str</code> <p>The type/key of the annotation to remove</p> required <code></code> get_raw_json \u00b6 <pre><code>get_raw_json() -&gt; Dict[str, Any]\n</code></pre> <p>Returns the raw JSON data for this entry.</p> <code></code> from_trace_entry \u00b6 <pre><code>from_trace_entry(entry: TraceEntry, entry_index: int = 0) -&gt; Dict[str, Any]\n</code></pre> <p>Create a HAR entry dictionary from a TraceEntry.</p> <p>Parameters:</p> Name Type Description Default <code>entry</code> <code>TraceEntry</code> <p>The TraceEntry to convert.</p> required <code>entry_index</code> <code>int</code> <p>The index of the entry (for ID generation if needed).</p> <code>0</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary representing a HAR entry.</p>"},{"location":"api/entries/#trace_shrink.entries.MultiFileTraceEntry","title":"MultiFileTraceEntry","text":"<pre><code>MultiFileTraceEntry(\n    index: int,\n    exchange: Dict[str, Any],\n    body_bytes: Optional[bytes],\n    annotations: Optional[Dict[str, str]] = None,\n)\n</code></pre> <p>               Bases: <code>TraceEntry</code></p> <p>TraceEntry backed by a set of files produced by OutputStore.</p> <p>Expects a meta JSON dict like the one OutputStore writes, a body bytes object (or None), and optional annotations dict.</p>"},{"location":"api/entries/#trace_shrink.entries.MultiFileTraceEntry-attributes","title":"Attributes","text":"index \u00b6 <pre><code>index: int\n</code></pre> <p>The zero-based index of the entry in the archive.</p> <code></code> id \u00b6 <pre><code>id: str\n</code></pre> <p>A unique identifier for the entry.</p> <code></code> request \u00b6 <pre><code>request: RequestDetails\n</code></pre> <p>Details of the HTTP request, with merged override headers.</p> <code></code> response \u00b6 <pre><code>response: ResponseDetails\n</code></pre> <p>Details of the HTTP response, with merged override headers.</p> <code></code> timeline \u00b6 <pre><code>timeline: TimelineDetails\n</code></pre> <p>Timeline details of the HTTP exchange.</p> <code></code> comment \u00b6 <pre><code>comment: Optional[str]\n</code></pre> <p>An optional comment for the entry.</p> <code></code> highlight \u00b6 <pre><code>highlight: Optional[str]\n</code></pre> <p>An optional highlight style for the entry (e.g., 'red', 'yellow', 'strike').</p> <code></code> annotations \u00b6 <pre><code>annotations: Dict[str, str]\n</code></pre> <p>Return annotations dict, merging overrides with original annotations.</p> <p>Filters out None values (which represent removed annotations).</p> <code></code> content \u00b6 <pre><code>content: bytes | str\n</code></pre> <p>The content of the entry, extracted from the response body.</p> <code></code> content_bytes \u00b6 <pre><code>content_bytes: bytes\n</code></pre> <p>The content of the entry as bytes, converting strings if necessary.</p> <code></code> format \u00b6 <pre><code>format: Optional[Format]\n</code></pre> <p>The format of the entry (HLS, DASH, or None), determined from content type or URL.</p>"},{"location":"api/entries/#trace_shrink.entries.MultiFileTraceEntry-functions","title":"Functions","text":"set_comment \u00b6 <pre><code>set_comment(comment: str) -&gt; None\n</code></pre> <p>Set a comment on this entry.</p> <code></code> set_highlight \u00b6 <pre><code>set_highlight(highlight: str) -&gt; None\n</code></pre> <p>Set a highlight style on this entry.</p> <p>Supported values: - \"red\" (0) - \"yellow\" (1) - \"green\" (2) - \"blue\" (3) - \"purple\" (4) - \"grey\" (5) - \"strike\" (strike-through)</p> <p>Parameters:</p> Name Type Description Default <code>highlight</code> <code>str</code> <p>The highlight style to apply.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid highlight value is provided.</p> <code></code> add_request_header \u00b6 <pre><code>add_request_header(name: str, value: str) -&gt; None\n</code></pre> <p>Add or update a header in the request.</p> <code></code> add_response_header \u00b6 <pre><code>add_response_header(name: str, value: str) -&gt; None\n</code></pre> <p>Add or update a header in the response.</p> <code></code> set_response_content \u00b6 <pre><code>set_response_content(content: str) -&gt; None\n</code></pre> <p>Set the response body content.</p> <code></code> add_annotation \u00b6 <pre><code>add_annotation(annotation_type: str, content: str) -&gt; None\n</code></pre> <p>Add or update an annotation.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_type</code> <code>str</code> <p>The type/key of the annotation (e.g., \"digest\", \"dash-preview\")</p> required <code>content</code> <code>str</code> <p>The annotation content/value</p> required <code></code> remove_annotation \u00b6 <pre><code>remove_annotation(annotation_type: str) -&gt; None\n</code></pre> <p>Remove an annotation.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_type</code> <code>str</code> <p>The type/key of the annotation to remove</p> required <code></code> from_files \u00b6 <pre><code>from_files(\n    index: int,\n    meta_path: str,\n    body_path: str,\n    annotations_paths: Optional[List[str]] = None,\n)\n</code></pre>"},{"location":"api/entries/#trace_shrink.entries.ProxymanLogV2Entry","title":"ProxymanLogV2Entry","text":"<pre><code>ProxymanLogV2Entry(entry_name: str, raw_data: Dict[str, Any], reader: Any)\n</code></pre> <p>               Bases: <code>TraceEntry</code></p> <p>Represents a single request/response entry from a Proxyman log file. This class provides access to entry data according to the CaptureEntry interface.</p> <p>Parameters:</p> Name Type Description Default <code>entry_name</code> <code>str</code> <p>The internal filename or identifier for this entry in the archive.</p> required <code>raw_data</code> <code>Dict[str, Any]</code> <p>The dictionary containing the parsed JSON content of the entry.</p> required <code>reader</code> <code>Any</code> <p>The ProxymanLogV2Reader instance that this entry belongs to.</p> required"},{"location":"api/entries/#trace_shrink.entries.ProxymanLogV2Entry-attributes","title":"Attributes","text":"index \u00b6 <pre><code>index: int\n</code></pre> <p>The zero-based index of the entry in the archive.</p> <code></code> id \u00b6 <pre><code>id: str\n</code></pre> <p>A unique identifier for the entry.</p> <code></code> request \u00b6 <pre><code>request: RequestDetails\n</code></pre> <p>Details of the HTTP request, with merged override headers.</p> <code></code> response \u00b6 <pre><code>response: ResponseDetails\n</code></pre> <p>Details of the HTTP response, with merged override headers.</p> <code></code> timeline \u00b6 <pre><code>timeline: TimelineDetails\n</code></pre> <p>Timeline details of the HTTP exchange.</p> <code></code> comment \u00b6 <pre><code>comment: Optional[str]\n</code></pre> <p>An optional comment for the entry.</p> <code></code> highlight \u00b6 <pre><code>highlight: Optional[str]\n</code></pre> <p>An optional highlight style for the entry (e.g., 'red', 'yellow', 'strike').</p> <code></code> annotations \u00b6 <pre><code>annotations: Dict[str, str]\n</code></pre> <p>Return annotations dict, merging overrides with original annotations.</p> <p>Filters out None values (which represent removed annotations).</p> <code></code> content \u00b6 <pre><code>content: bytes | str\n</code></pre> <p>The content of the entry, extracted from the response body.</p> <code></code> content_bytes \u00b6 <pre><code>content_bytes: bytes\n</code></pre> <p>The content of the entry as bytes, converting strings if necessary.</p> <code></code> format \u00b6 <pre><code>format: Optional[Format]\n</code></pre> <p>The format of the entry (HLS, DASH, or None), determined from content type or URL.</p>"},{"location":"api/entries/#trace_shrink.entries.ProxymanLogV2Entry-functions","title":"Functions","text":"set_comment \u00b6 <pre><code>set_comment(comment: str) -&gt; None\n</code></pre> <p>Set a comment on this entry.</p> <code></code> set_highlight \u00b6 <pre><code>set_highlight(highlight: str) -&gt; None\n</code></pre> <p>Set a highlight style on this entry.</p> <p>Supported values: - \"red\" (0) - \"yellow\" (1) - \"green\" (2) - \"blue\" (3) - \"purple\" (4) - \"grey\" (5) - \"strike\" (strike-through)</p> <p>Parameters:</p> Name Type Description Default <code>highlight</code> <code>str</code> <p>The highlight style to apply.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid highlight value is provided.</p> <code></code> add_request_header \u00b6 <pre><code>add_request_header(name: str, value: str) -&gt; None\n</code></pre> <p>Add or update a header in the request.</p> <code></code> add_response_header \u00b6 <pre><code>add_response_header(name: str, value: str) -&gt; None\n</code></pre> <p>Add or update a header in the response.</p> <code></code> set_response_content \u00b6 <pre><code>set_response_content(content: str) -&gt; None\n</code></pre> <p>Set the response body content.</p> <code></code> add_annotation \u00b6 <pre><code>add_annotation(annotation_type: str, content: str) -&gt; None\n</code></pre> <p>Add or update an annotation.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_type</code> <code>str</code> <p>The type/key of the annotation (e.g., \"digest\", \"dash-preview\")</p> required <code>content</code> <code>str</code> <p>The annotation content/value</p> required <code></code> remove_annotation \u00b6 <pre><code>remove_annotation(annotation_type: str) -&gt; None\n</code></pre> <p>Remove an annotation.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_type</code> <code>str</code> <p>The type/key of the annotation to remove</p> required <code></code> get_raw_json \u00b6 <pre><code>get_raw_json() -&gt; Dict[str, Any]\n</code></pre> <p>Returns the raw, unmodified JSON data for this entry.</p> <code></code> from_trace_entry \u00b6 <pre><code>from_trace_entry(\n    entry: TraceEntry, index: int = 0\n) -&gt; Tuple[Dict[str, Any], str]\n</code></pre> <p>Create a Proxyman entry dictionary and filename from a TraceEntry.</p> <p>Parameters:</p> Name Type Description Default <code>entry</code> <code>TraceEntry</code> <p>The TraceEntry to convert.</p> required <code>index</code> <code>int</code> <p>The index of the entry (used in filename).</p> <code>0</code> <p>Returns:</p> Type Description <code>Tuple[Dict[str, Any], str]</code> <p>Tuple of (entry_data_dict, filename).</p>"},{"location":"api/entries/#trace_shrink.entries.RequestsResponseTraceEntry","title":"RequestsResponseTraceEntry","text":"<pre><code>RequestsResponseTraceEntry(\n    response: \"Response\", index: int = 0, entry_id: Optional[str] = None\n)\n</code></pre> <p>               Bases: <code>TraceEntry</code></p> <p>TraceEntry adapter that wraps a requests.Response object.</p> <p>This class provides a TraceEntry interface for a requests.Response object, allowing it to be used with trace_shrink APIs that expect TraceEntry instances. Note: This is a read-only entry type (no corresponding Writer class), but mutations via the parent TraceEntry class are fully supported.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>'Response'</code> <p>The requests.Response object to wrap</p> required <code>index</code> <code>int</code> <p>The index of this entry (default: 0)</p> <code>0</code> <code>entry_id</code> <code>Optional[str]</code> <p>Optional unique identifier (default: str(index))</p> <code>None</code>"},{"location":"api/entries/#trace_shrink.entries.RequestsResponseTraceEntry-attributes","title":"Attributes","text":"index \u00b6 <pre><code>index: int\n</code></pre> <p>The zero-based index of the entry in the archive.</p> <code></code> id \u00b6 <pre><code>id: str\n</code></pre> <p>A unique identifier for the entry.</p> <code></code> request \u00b6 <pre><code>request: RequestDetails\n</code></pre> <p>Details of the HTTP request, with merged override headers.</p> <code></code> response \u00b6 <pre><code>response: ResponseDetails\n</code></pre> <p>Details of the HTTP response, with merged override headers.</p> <code></code> timeline \u00b6 <pre><code>timeline: TimelineDetails\n</code></pre> <p>Timeline details of the HTTP exchange.</p> <code></code> comment \u00b6 <pre><code>comment: Optional[str]\n</code></pre> <p>An optional comment for the entry.</p> <code></code> highlight \u00b6 <pre><code>highlight: Optional[str]\n</code></pre> <p>An optional highlight style for the entry (e.g., 'red', 'yellow', 'strike').</p> <code></code> annotations \u00b6 <pre><code>annotations: Dict[str, str]\n</code></pre> <p>Return annotations dict, merging overrides with original annotations.</p> <p>Filters out None values (which represent removed annotations).</p> <code></code> content \u00b6 <pre><code>content: bytes | str\n</code></pre> <p>The content of the entry, extracted from the response body.</p> <code></code> content_bytes \u00b6 <pre><code>content_bytes: bytes\n</code></pre> <p>The content of the entry as bytes, converting strings if necessary.</p> <code></code> format \u00b6 <pre><code>format: Optional[Format]\n</code></pre> <p>The format of the entry (HLS, DASH, or None), determined from content type or URL.</p> <code></code> elapsed_ms \u00b6 <pre><code>elapsed_ms: int\n</code></pre> <p>Get the elapsed time in milliseconds from the response.</p> <code></code> reason \u00b6 <pre><code>reason: Optional[str]\n</code></pre> <p>Get the HTTP reason phrase from the response.</p>"},{"location":"api/entries/#trace_shrink.entries.RequestsResponseTraceEntry-functions","title":"Functions","text":"set_comment \u00b6 <pre><code>set_comment(comment: str) -&gt; None\n</code></pre> <p>Set a comment on this entry.</p> <code></code> set_highlight \u00b6 <pre><code>set_highlight(highlight: str) -&gt; None\n</code></pre> <p>Set a highlight style on this entry.</p> <p>Supported values: - \"red\" (0) - \"yellow\" (1) - \"green\" (2) - \"blue\" (3) - \"purple\" (4) - \"grey\" (5) - \"strike\" (strike-through)</p> <p>Parameters:</p> Name Type Description Default <code>highlight</code> <code>str</code> <p>The highlight style to apply.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid highlight value is provided.</p> <code></code> add_request_header \u00b6 <pre><code>add_request_header(name: str, value: str) -&gt; None\n</code></pre> <p>Add or update a header in the request.</p> <code></code> add_response_header \u00b6 <pre><code>add_response_header(name: str, value: str) -&gt; None\n</code></pre> <p>Add or update a header in the response.</p> <code></code> set_response_content \u00b6 <pre><code>set_response_content(content: str) -&gt; None\n</code></pre> <p>Set the response body content.</p> <code></code> add_annotation \u00b6 <pre><code>add_annotation(annotation_type: str, content: str) -&gt; None\n</code></pre> <p>Add or update an annotation.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_type</code> <code>str</code> <p>The type/key of the annotation (e.g., \"digest\", \"dash-preview\")</p> required <code>content</code> <code>str</code> <p>The annotation content/value</p> required <code></code> remove_annotation \u00b6 <pre><code>remove_annotation(annotation_type: str) -&gt; None\n</code></pre> <p>Remove an annotation.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_type</code> <code>str</code> <p>The type/key of the annotation to remove</p> required"},{"location":"api/entries/#trace_shrink.entries.RequestDetails","title":"RequestDetails","text":"<pre><code>RequestDetails(\n    url: URL, method: str, headers: Dict[str, str], body: Optional[bytes] = None\n)\n</code></pre> <p>Concrete class for details of an HTTP request.</p>"},{"location":"api/entries/#trace_shrink.entries.RequestDetails-attributes","title":"Attributes","text":"url \u00b6 <pre><code>url: URL\n</code></pre> <p>The URL of the request.</p> <code></code> headers \u00b6 <pre><code>headers: Dict[str, str]\n</code></pre> <p>A dictionary of request headers.</p> <code></code> method \u00b6 <pre><code>method: str\n</code></pre> <p>The HTTP method (e.g., 'GET', 'POST').</p> <code></code> body \u00b6 <pre><code>body: Optional[bytes]\n</code></pre> <p>The request body, if available.</p>"},{"location":"api/entries/#trace_shrink.entries.ResponseBodyDetails","title":"ResponseBodyDetails","text":"<pre><code>ResponseBodyDetails(\n    text: Optional[str] = None,\n    raw_size: Optional[int] = None,\n    compressed_size: Optional[int] = None,\n    decoded_body: Optional[bytes] = None,\n)\n</code></pre> <p>Concrete class for details of an HTTP response body.</p>"},{"location":"api/entries/#trace_shrink.entries.ResponseBodyDetails-attributes","title":"Attributes","text":"text \u00b6 <pre><code>text: Optional[str]\n</code></pre> <p>The textual content of the response body, if available.</p> <code></code> raw_size \u00b6 <pre><code>raw_size: Optional[int]\n</code></pre> <p>The raw size of the response body in bytes.</p> <code></code> compressed_size \u00b6 <pre><code>compressed_size: Optional[int]\n</code></pre> <p>The compressed (transfer) size of the response body in bytes.</p>"},{"location":"api/entries/#trace_shrink.entries.ResponseDetails","title":"ResponseDetails","text":"<pre><code>ResponseDetails(\n    headers: Dict[str, str],\n    status_code: int,\n    mime_type: Optional[str] = None,\n    content_type: Optional[str] = None,\n    body: Optional[ResponseBodyDetails] = None,\n)\n</code></pre> <p>Concrete class for details of an HTTP response.</p>"},{"location":"api/entries/#trace_shrink.entries.ResponseDetails-attributes","title":"Attributes","text":"headers \u00b6 <pre><code>headers: Dict[str, str]\n</code></pre> <p>A dictionary of response headers.</p> <code></code> mime_type \u00b6 <pre><code>mime_type: Optional[str]\n</code></pre> <p>The MIME type of the response.</p> <code></code> content_type \u00b6 <pre><code>content_type: Optional[str]\n</code></pre> <p>The content type of the response.</p> <code></code> body \u00b6 <pre><code>body: ResponseBodyDetails\n</code></pre> <p>Details of the response body.</p> <code></code> status_code \u00b6 <pre><code>status_code: int\n</code></pre> <p>The HTTP status code of the response.</p>"},{"location":"api/entries/#trace_shrink.entries.TimelineDetails","title":"TimelineDetails","text":"<pre><code>TimelineDetails(\n    request_start: Optional[datetime] = None,\n    request_end: Optional[datetime] = None,\n    response_start: Optional[datetime] = None,\n    response_end: Optional[datetime] = None,\n)\n</code></pre> <p>Concrete class for timeline details of an HTTP exchange.</p>"},{"location":"api/entries/#trace_shrink.entries.TimelineDetails-attributes","title":"Attributes","text":"request_start \u00b6 <pre><code>request_start: Optional[datetime]\n</code></pre> <p>The start time of the request.</p> <code></code> request_end \u00b6 <pre><code>request_end: Optional[datetime]\n</code></pre> <p>The end time of the request.</p> <code></code> response_start \u00b6 <pre><code>response_start: Optional[datetime]\n</code></pre> <p>The start time of the response.</p> <code></code> response_end \u00b6 <pre><code>response_end: Optional[datetime]\n</code></pre> <p>The end time of the response.</p>"},{"location":"api/entries/#trace_shrink.entries.TraceEntry","title":"TraceEntry","text":"<pre><code>TraceEntry(\n    index: int,\n    entry_id: str,\n    request: RequestDetails,\n    response: ResponseDetails,\n    timeline: TimelineDetails,\n    comment: Optional[str] = None,\n    highlight: Optional[str] = None,\n    annotations: Optional[Dict[str, str]] = None,\n)\n</code></pre> <p>Concrete model class for a single entry in a trace archive.</p>"},{"location":"api/entries/#trace_shrink.entries.TraceEntry-attributes","title":"Attributes","text":"index \u00b6 <pre><code>index: int\n</code></pre> <p>The zero-based index of the entry in the archive.</p> <code></code> id \u00b6 <pre><code>id: str\n</code></pre> <p>A unique identifier for the entry.</p> <code></code> request \u00b6 <pre><code>request: RequestDetails\n</code></pre> <p>Details of the HTTP request, with merged override headers.</p> <code></code> response \u00b6 <pre><code>response: ResponseDetails\n</code></pre> <p>Details of the HTTP response, with merged override headers.</p> <code></code> timeline \u00b6 <pre><code>timeline: TimelineDetails\n</code></pre> <p>Timeline details of the HTTP exchange.</p> <code></code> comment \u00b6 <pre><code>comment: Optional[str]\n</code></pre> <p>An optional comment for the entry.</p> <code></code> highlight \u00b6 <pre><code>highlight: Optional[str]\n</code></pre> <p>An optional highlight style for the entry (e.g., 'red', 'yellow', 'strike').</p> <code></code> annotations \u00b6 <pre><code>annotations: Dict[str, str]\n</code></pre> <p>Return annotations dict, merging overrides with original annotations.</p> <p>Filters out None values (which represent removed annotations).</p> <code></code> content \u00b6 <pre><code>content: bytes | str\n</code></pre> <p>The content of the entry, extracted from the response body.</p> <code></code> content_bytes \u00b6 <pre><code>content_bytes: bytes\n</code></pre> <p>The content of the entry as bytes, converting strings if necessary.</p> <code></code> format \u00b6 <pre><code>format: Optional[Format]\n</code></pre> <p>The format of the entry (HLS, DASH, or None), determined from content type or URL.</p>"},{"location":"api/entries/#trace_shrink.entries.TraceEntry-functions","title":"Functions","text":"set_comment \u00b6 <pre><code>set_comment(comment: str) -&gt; None\n</code></pre> <p>Set a comment on this entry.</p> <code></code> set_highlight \u00b6 <pre><code>set_highlight(highlight: str) -&gt; None\n</code></pre> <p>Set a highlight style on this entry.</p> <p>Supported values: - \"red\" (0) - \"yellow\" (1) - \"green\" (2) - \"blue\" (3) - \"purple\" (4) - \"grey\" (5) - \"strike\" (strike-through)</p> <p>Parameters:</p> Name Type Description Default <code>highlight</code> <code>str</code> <p>The highlight style to apply.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid highlight value is provided.</p> <code></code> add_request_header \u00b6 <pre><code>add_request_header(name: str, value: str) -&gt; None\n</code></pre> <p>Add or update a header in the request.</p> <code></code> add_response_header \u00b6 <pre><code>add_response_header(name: str, value: str) -&gt; None\n</code></pre> <p>Add or update a header in the response.</p> <code></code> set_response_content \u00b6 <pre><code>set_response_content(content: str) -&gt; None\n</code></pre> <p>Set the response body content.</p> <code></code> add_annotation \u00b6 <pre><code>add_annotation(annotation_type: str, content: str) -&gt; None\n</code></pre> <p>Add or update an annotation.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_type</code> <code>str</code> <p>The type/key of the annotation (e.g., \"digest\", \"dash-preview\")</p> required <code>content</code> <code>str</code> <p>The annotation content/value</p> required <code></code> remove_annotation \u00b6 <pre><code>remove_annotation(annotation_type: str) -&gt; None\n</code></pre> <p>Remove an annotation.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_type</code> <code>str</code> <p>The type/key of the annotation to remove</p> required"},{"location":"api/entries/#trace_shrink.entries-modules","title":"Modules","text":""},{"location":"api/entries/#trace_shrink.entries.bodylogger_entry","title":"bodylogger_entry","text":""},{"location":"api/entries/#trace_shrink.entries.bodylogger_entry-classes","title":"Classes","text":"BodyLoggerEntry \u00b6 <pre><code>BodyLoggerEntry(\n    index: int,\n    entry_id: str,\n    request: RequestDetails,\n    response: ResponseDetails,\n    timeline: TimelineDetails,\n    comment: Optional[str] = None,\n    highlight: Optional[str] = None,\n    annotations: Optional[Dict[str, str]] = None,\n)\n</code></pre> <p>               Bases: <code>TraceEntry</code></p> <p>Represents a single entry from a bodylogger file.</p> <p>This is a TraceEntry with bodylogger-specific properties for backward compatibility.</p> Attributes\u00b6 <code></code> service_id \u00b6 <pre><code>service_id: Optional[str]\n</code></pre> <p>Return the service ID for this entry.</p> <code></code> session_id \u00b6 <pre><code>session_id: Optional[str]\n</code></pre> <p>Return the session ID for this entry.</p> <code></code> correlation_id \u00b6 <pre><code>correlation_id: int\n</code></pre> <p>Return the correlation ID for this entry.</p> <code></code> index \u00b6 <pre><code>index: int\n</code></pre> <p>The zero-based index of the entry in the archive.</p> <code></code> id \u00b6 <pre><code>id: str\n</code></pre> <p>A unique identifier for the entry.</p> <code></code> request \u00b6 <pre><code>request: RequestDetails\n</code></pre> <p>Details of the HTTP request, with merged override headers.</p> <code></code> response \u00b6 <pre><code>response: ResponseDetails\n</code></pre> <p>Details of the HTTP response, with merged override headers.</p> <code></code> timeline \u00b6 <pre><code>timeline: TimelineDetails\n</code></pre> <p>Timeline details of the HTTP exchange.</p> <code></code> comment \u00b6 <pre><code>comment: Optional[str]\n</code></pre> <p>An optional comment for the entry.</p> <code></code> highlight \u00b6 <pre><code>highlight: Optional[str]\n</code></pre> <p>An optional highlight style for the entry (e.g., 'red', 'yellow', 'strike').</p> <code></code> annotations \u00b6 <pre><code>annotations: Dict[str, str]\n</code></pre> <p>Return annotations dict, merging overrides with original annotations.</p> <p>Filters out None values (which represent removed annotations).</p> <code></code> content \u00b6 <pre><code>content: bytes | str\n</code></pre> <p>The content of the entry, extracted from the response body.</p> <code></code> content_bytes \u00b6 <pre><code>content_bytes: bytes\n</code></pre> <p>The content of the entry as bytes, converting strings if necessary.</p> <code></code> format \u00b6 <pre><code>format: Optional[Format]\n</code></pre> <p>The format of the entry (HLS, DASH, or None), determined from content type or URL.</p> Functions\u00b6 <code></code> get_raw_data \u00b6 <pre><code>get_raw_data() -&gt; Dict[str, Any]\n</code></pre> <p>Returns the raw data for this entry.</p> <code></code> set_comment \u00b6 <pre><code>set_comment(comment: str) -&gt; None\n</code></pre> <p>Set a comment on this entry.</p> <code></code> set_highlight \u00b6 <pre><code>set_highlight(highlight: str) -&gt; None\n</code></pre> <p>Set a highlight style on this entry.</p> <p>Supported values: - \"red\" (0) - \"yellow\" (1) - \"green\" (2) - \"blue\" (3) - \"purple\" (4) - \"grey\" (5) - \"strike\" (strike-through)</p> <p>Parameters:</p> Name Type Description Default <code>highlight</code> <code>str</code> <p>The highlight style to apply.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid highlight value is provided.</p> <code></code> add_request_header \u00b6 <pre><code>add_request_header(name: str, value: str) -&gt; None\n</code></pre> <p>Add or update a header in the request.</p> <code></code> add_response_header \u00b6 <pre><code>add_response_header(name: str, value: str) -&gt; None\n</code></pre> <p>Add or update a header in the response.</p> <code></code> set_response_content \u00b6 <pre><code>set_response_content(content: str) -&gt; None\n</code></pre> <p>Set the response body content.</p> <code></code> add_annotation \u00b6 <pre><code>add_annotation(annotation_type: str, content: str) -&gt; None\n</code></pre> <p>Add or update an annotation.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_type</code> <code>str</code> <p>The type/key of the annotation (e.g., \"digest\", \"dash-preview\")</p> required <code>content</code> <code>str</code> <p>The annotation content/value</p> required <code></code> remove_annotation \u00b6 <pre><code>remove_annotation(annotation_type: str) -&gt; None\n</code></pre> <p>Remove an annotation.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_type</code> <code>str</code> <p>The type/key of the annotation to remove</p> required"},{"location":"api/entries/#trace_shrink.entries.bodylogger_entry-functions","title":"Functions","text":"parse_bodylogger_entry \u00b6 <pre><code>parse_bodylogger_entry(\n    record_data: Dict[str, Any], reader: Any, entry_index: int\n) -&gt; BodyLoggerEntry\n</code></pre> <p>Parse a bodylogger record into a BodyLoggerEntry.</p> <p>Parameters:</p> Name Type Description Default <code>record_data</code> <code>Dict[str, Any]</code> <p>The raw dictionary for the bodylogger record.</p> required <code>reader</code> <code>Any</code> <p>The BodyLoggerReader instance (for compatibility, not used).</p> required <code>entry_index</code> <code>int</code> <p>The index of this entry within the bodylogger file.</p> required <p>Returns:</p> Name Type Description <code>BodyLoggerEntry</code> <code>BodyLoggerEntry</code> <p>A BodyLoggerEntry instance with parsed data.</p>"},{"location":"api/entries/#trace_shrink.entries.har_entry","title":"har_entry","text":""},{"location":"api/entries/#trace_shrink.entries.har_entry-classes","title":"Classes","text":"HarEntry \u00b6 <pre><code>HarEntry(har_entry_data: Dict[str, Any], reader: Any, entry_index: int)\n</code></pre> <p>               Bases: <code>TraceEntry</code></p> <p>Represents a single entry in a HAR file, providing access to request, response, and timeline details.</p> <p>Parameters:</p> Name Type Description Default <code>har_entry_data</code> <code>Dict[str, Any]</code> <p>The raw dictionary for the HAR entry.</p> required <code>reader</code> <code>Any</code> <p>The HarReader instance that this entry belongs to.</p> required <code>entry_index</code> <code>int</code> <p>The index of this entry within the HAR file.</p> required Attributes\u00b6 <code></code> time \u00b6 <pre><code>time: Optional[float]\n</code></pre> <p>Total time for the entry in milliseconds from the HAR spec.</p> <code></code> index \u00b6 <pre><code>index: int\n</code></pre> <p>The zero-based index of the entry in the archive.</p> <code></code> id \u00b6 <pre><code>id: str\n</code></pre> <p>A unique identifier for the entry.</p> <code></code> request \u00b6 <pre><code>request: RequestDetails\n</code></pre> <p>Details of the HTTP request, with merged override headers.</p> <code></code> response \u00b6 <pre><code>response: ResponseDetails\n</code></pre> <p>Details of the HTTP response, with merged override headers.</p> <code></code> timeline \u00b6 <pre><code>timeline: TimelineDetails\n</code></pre> <p>Timeline details of the HTTP exchange.</p> <code></code> comment \u00b6 <pre><code>comment: Optional[str]\n</code></pre> <p>An optional comment for the entry.</p> <code></code> highlight \u00b6 <pre><code>highlight: Optional[str]\n</code></pre> <p>An optional highlight style for the entry (e.g., 'red', 'yellow', 'strike').</p> <code></code> annotations \u00b6 <pre><code>annotations: Dict[str, str]\n</code></pre> <p>Return annotations dict, merging overrides with original annotations.</p> <p>Filters out None values (which represent removed annotations).</p> <code></code> content \u00b6 <pre><code>content: bytes | str\n</code></pre> <p>The content of the entry, extracted from the response body.</p> <code></code> content_bytes \u00b6 <pre><code>content_bytes: bytes\n</code></pre> <p>The content of the entry as bytes, converting strings if necessary.</p> <code></code> format \u00b6 <pre><code>format: Optional[Format]\n</code></pre> <p>The format of the entry (HLS, DASH, or None), determined from content type or URL.</p> Functions\u00b6 <code></code> get_raw_json \u00b6 <pre><code>get_raw_json() -&gt; Dict[str, Any]\n</code></pre> <p>Returns the raw JSON data for this entry.</p> <code></code> from_trace_entry \u00b6 <pre><code>from_trace_entry(entry: TraceEntry, entry_index: int = 0) -&gt; Dict[str, Any]\n</code></pre> <p>Create a HAR entry dictionary from a TraceEntry.</p> <p>Parameters:</p> Name Type Description Default <code>entry</code> <code>TraceEntry</code> <p>The TraceEntry to convert.</p> required <code>entry_index</code> <code>int</code> <p>The index of the entry (for ID generation if needed).</p> <code>0</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary representing a HAR entry.</p> <code></code> set_comment \u00b6 <pre><code>set_comment(comment: str) -&gt; None\n</code></pre> <p>Set a comment on this entry.</p> <code></code> set_highlight \u00b6 <pre><code>set_highlight(highlight: str) -&gt; None\n</code></pre> <p>Set a highlight style on this entry.</p> <p>Supported values: - \"red\" (0) - \"yellow\" (1) - \"green\" (2) - \"blue\" (3) - \"purple\" (4) - \"grey\" (5) - \"strike\" (strike-through)</p> <p>Parameters:</p> Name Type Description Default <code>highlight</code> <code>str</code> <p>The highlight style to apply.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid highlight value is provided.</p> <code></code> add_request_header \u00b6 <pre><code>add_request_header(name: str, value: str) -&gt; None\n</code></pre> <p>Add or update a header in the request.</p> <code></code> add_response_header \u00b6 <pre><code>add_response_header(name: str, value: str) -&gt; None\n</code></pre> <p>Add or update a header in the response.</p> <code></code> set_response_content \u00b6 <pre><code>set_response_content(content: str) -&gt; None\n</code></pre> <p>Set the response body content.</p> <code></code> add_annotation \u00b6 <pre><code>add_annotation(annotation_type: str, content: str) -&gt; None\n</code></pre> <p>Add or update an annotation.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_type</code> <code>str</code> <p>The type/key of the annotation (e.g., \"digest\", \"dash-preview\")</p> required <code>content</code> <code>str</code> <p>The annotation content/value</p> required <code></code> remove_annotation \u00b6 <pre><code>remove_annotation(annotation_type: str) -&gt; None\n</code></pre> <p>Remove an annotation.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_type</code> <code>str</code> <p>The type/key of the annotation to remove</p> required"},{"location":"api/entries/#trace_shrink.entries.har_entry-functions","title":"Functions","text":""},{"location":"api/entries/#trace_shrink.entries.multifile_entry","title":"multifile_entry","text":""},{"location":"api/entries/#trace_shrink.entries.multifile_entry-classes","title":"Classes","text":"MultiFileTraceEntry \u00b6 <pre><code>MultiFileTraceEntry(\n    index: int,\n    exchange: Dict[str, Any],\n    body_bytes: Optional[bytes],\n    annotations: Optional[Dict[str, str]] = None,\n)\n</code></pre> <p>               Bases: <code>TraceEntry</code></p> <p>TraceEntry backed by a set of files produced by OutputStore.</p> <p>Expects a meta JSON dict like the one OutputStore writes, a body bytes object (or None), and optional annotations dict.</p> Attributes\u00b6 <code></code> index \u00b6 <pre><code>index: int\n</code></pre> <p>The zero-based index of the entry in the archive.</p> <code></code> id \u00b6 <pre><code>id: str\n</code></pre> <p>A unique identifier for the entry.</p> <code></code> request \u00b6 <pre><code>request: RequestDetails\n</code></pre> <p>Details of the HTTP request, with merged override headers.</p> <code></code> response \u00b6 <pre><code>response: ResponseDetails\n</code></pre> <p>Details of the HTTP response, with merged override headers.</p> <code></code> timeline \u00b6 <pre><code>timeline: TimelineDetails\n</code></pre> <p>Timeline details of the HTTP exchange.</p> <code></code> comment \u00b6 <pre><code>comment: Optional[str]\n</code></pre> <p>An optional comment for the entry.</p> <code></code> highlight \u00b6 <pre><code>highlight: Optional[str]\n</code></pre> <p>An optional highlight style for the entry (e.g., 'red', 'yellow', 'strike').</p> <code></code> annotations \u00b6 <pre><code>annotations: Dict[str, str]\n</code></pre> <p>Return annotations dict, merging overrides with original annotations.</p> <p>Filters out None values (which represent removed annotations).</p> <code></code> content \u00b6 <pre><code>content: bytes | str\n</code></pre> <p>The content of the entry, extracted from the response body.</p> <code></code> content_bytes \u00b6 <pre><code>content_bytes: bytes\n</code></pre> <p>The content of the entry as bytes, converting strings if necessary.</p> <code></code> format \u00b6 <pre><code>format: Optional[Format]\n</code></pre> <p>The format of the entry (HLS, DASH, or None), determined from content type or URL.</p> Functions\u00b6 <code></code> from_files \u00b6 <pre><code>from_files(\n    index: int,\n    meta_path: str,\n    body_path: str,\n    annotations_paths: Optional[List[str]] = None,\n)\n</code></pre> <code></code> set_comment \u00b6 <pre><code>set_comment(comment: str) -&gt; None\n</code></pre> <p>Set a comment on this entry.</p> <code></code> set_highlight \u00b6 <pre><code>set_highlight(highlight: str) -&gt; None\n</code></pre> <p>Set a highlight style on this entry.</p> <p>Supported values: - \"red\" (0) - \"yellow\" (1) - \"green\" (2) - \"blue\" (3) - \"purple\" (4) - \"grey\" (5) - \"strike\" (strike-through)</p> <p>Parameters:</p> Name Type Description Default <code>highlight</code> <code>str</code> <p>The highlight style to apply.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid highlight value is provided.</p> <code></code> add_request_header \u00b6 <pre><code>add_request_header(name: str, value: str) -&gt; None\n</code></pre> <p>Add or update a header in the request.</p> <code></code> add_response_header \u00b6 <pre><code>add_response_header(name: str, value: str) -&gt; None\n</code></pre> <p>Add or update a header in the response.</p> <code></code> set_response_content \u00b6 <pre><code>set_response_content(content: str) -&gt; None\n</code></pre> <p>Set the response body content.</p> <code></code> add_annotation \u00b6 <pre><code>add_annotation(annotation_type: str, content: str) -&gt; None\n</code></pre> <p>Add or update an annotation.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_type</code> <code>str</code> <p>The type/key of the annotation (e.g., \"digest\", \"dash-preview\")</p> required <code>content</code> <code>str</code> <p>The annotation content/value</p> required <code></code> remove_annotation \u00b6 <pre><code>remove_annotation(annotation_type: str) -&gt; None\n</code></pre> <p>Remove an annotation.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_type</code> <code>str</code> <p>The type/key of the annotation to remove</p> required"},{"location":"api/entries/#trace_shrink.entries.proxyman_entry","title":"proxyman_entry","text":""},{"location":"api/entries/#trace_shrink.entries.proxyman_entry-attributes","title":"Attributes","text":""},{"location":"api/entries/#trace_shrink.entries.proxyman_entry-classes","title":"Classes","text":"ProxymanLogV2Entry \u00b6 <pre><code>ProxymanLogV2Entry(entry_name: str, raw_data: Dict[str, Any], reader: Any)\n</code></pre> <p>               Bases: <code>TraceEntry</code></p> <p>Represents a single request/response entry from a Proxyman log file. This class provides access to entry data according to the CaptureEntry interface.</p> <p>Parameters:</p> Name Type Description Default <code>entry_name</code> <code>str</code> <p>The internal filename or identifier for this entry in the archive.</p> required <code>raw_data</code> <code>Dict[str, Any]</code> <p>The dictionary containing the parsed JSON content of the entry.</p> required <code>reader</code> <code>Any</code> <p>The ProxymanLogV2Reader instance that this entry belongs to.</p> required Attributes\u00b6 <code></code> index \u00b6 <pre><code>index: int\n</code></pre> <p>The zero-based index of the entry in the archive.</p> <code></code> id \u00b6 <pre><code>id: str\n</code></pre> <p>A unique identifier for the entry.</p> <code></code> request \u00b6 <pre><code>request: RequestDetails\n</code></pre> <p>Details of the HTTP request, with merged override headers.</p> <code></code> response \u00b6 <pre><code>response: ResponseDetails\n</code></pre> <p>Details of the HTTP response, with merged override headers.</p> <code></code> timeline \u00b6 <pre><code>timeline: TimelineDetails\n</code></pre> <p>Timeline details of the HTTP exchange.</p> <code></code> comment \u00b6 <pre><code>comment: Optional[str]\n</code></pre> <p>An optional comment for the entry.</p> <code></code> highlight \u00b6 <pre><code>highlight: Optional[str]\n</code></pre> <p>An optional highlight style for the entry (e.g., 'red', 'yellow', 'strike').</p> <code></code> annotations \u00b6 <pre><code>annotations: Dict[str, str]\n</code></pre> <p>Return annotations dict, merging overrides with original annotations.</p> <p>Filters out None values (which represent removed annotations).</p> <code></code> content \u00b6 <pre><code>content: bytes | str\n</code></pre> <p>The content of the entry, extracted from the response body.</p> <code></code> content_bytes \u00b6 <pre><code>content_bytes: bytes\n</code></pre> <p>The content of the entry as bytes, converting strings if necessary.</p> <code></code> format \u00b6 <pre><code>format: Optional[Format]\n</code></pre> <p>The format of the entry (HLS, DASH, or None), determined from content type or URL.</p> Functions\u00b6 <code></code> get_raw_json \u00b6 <pre><code>get_raw_json() -&gt; Dict[str, Any]\n</code></pre> <p>Returns the raw, unmodified JSON data for this entry.</p> <code></code> from_trace_entry \u00b6 <pre><code>from_trace_entry(\n    entry: TraceEntry, index: int = 0\n) -&gt; Tuple[Dict[str, Any], str]\n</code></pre> <p>Create a Proxyman entry dictionary and filename from a TraceEntry.</p> <p>Parameters:</p> Name Type Description Default <code>entry</code> <code>TraceEntry</code> <p>The TraceEntry to convert.</p> required <code>index</code> <code>int</code> <p>The index of the entry (used in filename).</p> <code>0</code> <p>Returns:</p> Type Description <code>Tuple[Dict[str, Any], str]</code> <p>Tuple of (entry_data_dict, filename).</p> <code></code> set_comment \u00b6 <pre><code>set_comment(comment: str) -&gt; None\n</code></pre> <p>Set a comment on this entry.</p> <code></code> set_highlight \u00b6 <pre><code>set_highlight(highlight: str) -&gt; None\n</code></pre> <p>Set a highlight style on this entry.</p> <p>Supported values: - \"red\" (0) - \"yellow\" (1) - \"green\" (2) - \"blue\" (3) - \"purple\" (4) - \"grey\" (5) - \"strike\" (strike-through)</p> <p>Parameters:</p> Name Type Description Default <code>highlight</code> <code>str</code> <p>The highlight style to apply.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid highlight value is provided.</p> <code></code> add_request_header \u00b6 <pre><code>add_request_header(name: str, value: str) -&gt; None\n</code></pre> <p>Add or update a header in the request.</p> <code></code> add_response_header \u00b6 <pre><code>add_response_header(name: str, value: str) -&gt; None\n</code></pre> <p>Add or update a header in the response.</p> <code></code> set_response_content \u00b6 <pre><code>set_response_content(content: str) -&gt; None\n</code></pre> <p>Set the response body content.</p> <code></code> add_annotation \u00b6 <pre><code>add_annotation(annotation_type: str, content: str) -&gt; None\n</code></pre> <p>Add or update an annotation.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_type</code> <code>str</code> <p>The type/key of the annotation (e.g., \"digest\", \"dash-preview\")</p> required <code>content</code> <code>str</code> <p>The annotation content/value</p> required <code></code> remove_annotation \u00b6 <pre><code>remove_annotation(annotation_type: str) -&gt; None\n</code></pre> <p>Remove an annotation.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_type</code> <code>str</code> <p>The type/key of the annotation to remove</p> required"},{"location":"api/entries/#trace_shrink.entries.proxyman_entry-functions","title":"Functions","text":""},{"location":"api/entries/#trace_shrink.entries.requests_entry","title":"requests_entry","text":""},{"location":"api/entries/#trace_shrink.entries.requests_entry-classes","title":"Classes","text":"RequestsResponseTraceEntry \u00b6 <pre><code>RequestsResponseTraceEntry(\n    response: \"Response\", index: int = 0, entry_id: Optional[str] = None\n)\n</code></pre> <p>               Bases: <code>TraceEntry</code></p> <p>TraceEntry adapter that wraps a requests.Response object.</p> <p>This class provides a TraceEntry interface for a requests.Response object, allowing it to be used with trace_shrink APIs that expect TraceEntry instances. Note: This is a read-only entry type (no corresponding Writer class), but mutations via the parent TraceEntry class are fully supported.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>'Response'</code> <p>The requests.Response object to wrap</p> required <code>index</code> <code>int</code> <p>The index of this entry (default: 0)</p> <code>0</code> <code>entry_id</code> <code>Optional[str]</code> <p>Optional unique identifier (default: str(index))</p> <code>None</code> Attributes\u00b6 <code></code> elapsed_ms \u00b6 <pre><code>elapsed_ms: int\n</code></pre> <p>Get the elapsed time in milliseconds from the response.</p> <code></code> reason \u00b6 <pre><code>reason: Optional[str]\n</code></pre> <p>Get the HTTP reason phrase from the response.</p> <code></code> index \u00b6 <pre><code>index: int\n</code></pre> <p>The zero-based index of the entry in the archive.</p> <code></code> id \u00b6 <pre><code>id: str\n</code></pre> <p>A unique identifier for the entry.</p> <code></code> request \u00b6 <pre><code>request: RequestDetails\n</code></pre> <p>Details of the HTTP request, with merged override headers.</p> <code></code> response \u00b6 <pre><code>response: ResponseDetails\n</code></pre> <p>Details of the HTTP response, with merged override headers.</p> <code></code> timeline \u00b6 <pre><code>timeline: TimelineDetails\n</code></pre> <p>Timeline details of the HTTP exchange.</p> <code></code> comment \u00b6 <pre><code>comment: Optional[str]\n</code></pre> <p>An optional comment for the entry.</p> <code></code> highlight \u00b6 <pre><code>highlight: Optional[str]\n</code></pre> <p>An optional highlight style for the entry (e.g., 'red', 'yellow', 'strike').</p> <code></code> annotations \u00b6 <pre><code>annotations: Dict[str, str]\n</code></pre> <p>Return annotations dict, merging overrides with original annotations.</p> <p>Filters out None values (which represent removed annotations).</p> <code></code> content \u00b6 <pre><code>content: bytes | str\n</code></pre> <p>The content of the entry, extracted from the response body.</p> <code></code> content_bytes \u00b6 <pre><code>content_bytes: bytes\n</code></pre> <p>The content of the entry as bytes, converting strings if necessary.</p> <code></code> format \u00b6 <pre><code>format: Optional[Format]\n</code></pre> <p>The format of the entry (HLS, DASH, or None), determined from content type or URL.</p> Functions\u00b6 <code></code> set_comment \u00b6 <pre><code>set_comment(comment: str) -&gt; None\n</code></pre> <p>Set a comment on this entry.</p> <code></code> set_highlight \u00b6 <pre><code>set_highlight(highlight: str) -&gt; None\n</code></pre> <p>Set a highlight style on this entry.</p> <p>Supported values: - \"red\" (0) - \"yellow\" (1) - \"green\" (2) - \"blue\" (3) - \"purple\" (4) - \"grey\" (5) - \"strike\" (strike-through)</p> <p>Parameters:</p> Name Type Description Default <code>highlight</code> <code>str</code> <p>The highlight style to apply.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid highlight value is provided.</p> <code></code> add_request_header \u00b6 <pre><code>add_request_header(name: str, value: str) -&gt; None\n</code></pre> <p>Add or update a header in the request.</p> <code></code> add_response_header \u00b6 <pre><code>add_response_header(name: str, value: str) -&gt; None\n</code></pre> <p>Add or update a header in the response.</p> <code></code> set_response_content \u00b6 <pre><code>set_response_content(content: str) -&gt; None\n</code></pre> <p>Set the response body content.</p> <code></code> add_annotation \u00b6 <pre><code>add_annotation(annotation_type: str, content: str) -&gt; None\n</code></pre> <p>Add or update an annotation.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_type</code> <code>str</code> <p>The type/key of the annotation (e.g., \"digest\", \"dash-preview\")</p> required <code>content</code> <code>str</code> <p>The annotation content/value</p> required <code></code> remove_annotation \u00b6 <pre><code>remove_annotation(annotation_type: str) -&gt; None\n</code></pre> <p>Remove an annotation.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_type</code> <code>str</code> <p>The type/key of the annotation to remove</p> required"},{"location":"api/entries/#trace_shrink.entries.trace_entry","title":"trace_entry","text":""},{"location":"api/entries/#trace_shrink.entries.trace_entry-classes","title":"Classes","text":"RequestDetails \u00b6 <pre><code>RequestDetails(\n    url: URL, method: str, headers: Dict[str, str], body: Optional[bytes] = None\n)\n</code></pre> <p>Concrete class for details of an HTTP request.</p> Attributes\u00b6 <code></code> url \u00b6 <pre><code>url: URL\n</code></pre> <p>The URL of the request.</p> <code></code> headers \u00b6 <pre><code>headers: Dict[str, str]\n</code></pre> <p>A dictionary of request headers.</p> <code></code> method \u00b6 <pre><code>method: str\n</code></pre> <p>The HTTP method (e.g., 'GET', 'POST').</p> <code></code> body \u00b6 <pre><code>body: Optional[bytes]\n</code></pre> <p>The request body, if available.</p> <code></code> ResponseBodyDetails \u00b6 <pre><code>ResponseBodyDetails(\n    text: Optional[str] = None,\n    raw_size: Optional[int] = None,\n    compressed_size: Optional[int] = None,\n    decoded_body: Optional[bytes] = None,\n)\n</code></pre> <p>Concrete class for details of an HTTP response body.</p> Attributes\u00b6 <code></code> text \u00b6 <pre><code>text: Optional[str]\n</code></pre> <p>The textual content of the response body, if available.</p> <code></code> raw_size \u00b6 <pre><code>raw_size: Optional[int]\n</code></pre> <p>The raw size of the response body in bytes.</p> <code></code> compressed_size \u00b6 <pre><code>compressed_size: Optional[int]\n</code></pre> <p>The compressed (transfer) size of the response body in bytes.</p> <code></code> ResponseDetails \u00b6 <pre><code>ResponseDetails(\n    headers: Dict[str, str],\n    status_code: int,\n    mime_type: Optional[str] = None,\n    content_type: Optional[str] = None,\n    body: Optional[ResponseBodyDetails] = None,\n)\n</code></pre> <p>Concrete class for details of an HTTP response.</p> Attributes\u00b6 <code></code> headers \u00b6 <pre><code>headers: Dict[str, str]\n</code></pre> <p>A dictionary of response headers.</p> <code></code> mime_type \u00b6 <pre><code>mime_type: Optional[str]\n</code></pre> <p>The MIME type of the response.</p> <code></code> content_type \u00b6 <pre><code>content_type: Optional[str]\n</code></pre> <p>The content type of the response.</p> <code></code> body \u00b6 <pre><code>body: ResponseBodyDetails\n</code></pre> <p>Details of the response body.</p> <code></code> status_code \u00b6 <pre><code>status_code: int\n</code></pre> <p>The HTTP status code of the response.</p> <code></code> TimelineDetails \u00b6 <pre><code>TimelineDetails(\n    request_start: Optional[datetime] = None,\n    request_end: Optional[datetime] = None,\n    response_start: Optional[datetime] = None,\n    response_end: Optional[datetime] = None,\n)\n</code></pre> <p>Concrete class for timeline details of an HTTP exchange.</p> Attributes\u00b6 <code></code> request_start \u00b6 <pre><code>request_start: Optional[datetime]\n</code></pre> <p>The start time of the request.</p> <code></code> request_end \u00b6 <pre><code>request_end: Optional[datetime]\n</code></pre> <p>The end time of the request.</p> <code></code> response_start \u00b6 <pre><code>response_start: Optional[datetime]\n</code></pre> <p>The start time of the response.</p> <code></code> response_end \u00b6 <pre><code>response_end: Optional[datetime]\n</code></pre> <p>The end time of the response.</p> <code></code> MergedResponseDetails \u00b6 <pre><code>MergedResponseDetails(\n    original: ResponseDetails, override_headers: Dict[str, str]\n)\n</code></pre> <p>               Bases: <code>ResponseDetails</code></p> <p>ResponseDetails wrapper that merges original headers with overrides.</p> Attributes\u00b6 <code></code> headers \u00b6 <pre><code>headers: Dict[str, str]\n</code></pre> <p>A dictionary of response headers.</p> <code></code> mime_type \u00b6 <pre><code>mime_type: Optional[str]\n</code></pre> <p>The MIME type of the response.</p> <code></code> content_type \u00b6 <pre><code>content_type: Optional[str]\n</code></pre> <p>The content type of the response.</p> <code></code> body \u00b6 <pre><code>body: ResponseBodyDetails\n</code></pre> <p>Details of the response body.</p> <code></code> status_code \u00b6 <pre><code>status_code: int\n</code></pre> <p>The HTTP status code of the response.</p> <code></code> TraceEntry \u00b6 <pre><code>TraceEntry(\n    index: int,\n    entry_id: str,\n    request: RequestDetails,\n    response: ResponseDetails,\n    timeline: TimelineDetails,\n    comment: Optional[str] = None,\n    highlight: Optional[str] = None,\n    annotations: Optional[Dict[str, str]] = None,\n)\n</code></pre> <p>Concrete model class for a single entry in a trace archive.</p> Attributes\u00b6 <code></code> index \u00b6 <pre><code>index: int\n</code></pre> <p>The zero-based index of the entry in the archive.</p> <code></code> id \u00b6 <pre><code>id: str\n</code></pre> <p>A unique identifier for the entry.</p> <code></code> request \u00b6 <pre><code>request: RequestDetails\n</code></pre> <p>Details of the HTTP request, with merged override headers.</p> <code></code> response \u00b6 <pre><code>response: ResponseDetails\n</code></pre> <p>Details of the HTTP response, with merged override headers.</p> <code></code> timeline \u00b6 <pre><code>timeline: TimelineDetails\n</code></pre> <p>Timeline details of the HTTP exchange.</p> <code></code> comment \u00b6 <pre><code>comment: Optional[str]\n</code></pre> <p>An optional comment for the entry.</p> <code></code> highlight \u00b6 <pre><code>highlight: Optional[str]\n</code></pre> <p>An optional highlight style for the entry (e.g., 'red', 'yellow', 'strike').</p> <code></code> annotations \u00b6 <pre><code>annotations: Dict[str, str]\n</code></pre> <p>Return annotations dict, merging overrides with original annotations.</p> <p>Filters out None values (which represent removed annotations).</p> <code></code> content \u00b6 <pre><code>content: bytes | str\n</code></pre> <p>The content of the entry, extracted from the response body.</p> <code></code> content_bytes \u00b6 <pre><code>content_bytes: bytes\n</code></pre> <p>The content of the entry as bytes, converting strings if necessary.</p> <code></code> format \u00b6 <pre><code>format: Optional[Format]\n</code></pre> <p>The format of the entry (HLS, DASH, or None), determined from content type or URL.</p> Functions\u00b6 <code></code> set_comment \u00b6 <pre><code>set_comment(comment: str) -&gt; None\n</code></pre> <p>Set a comment on this entry.</p> <code></code> set_highlight \u00b6 <pre><code>set_highlight(highlight: str) -&gt; None\n</code></pre> <p>Set a highlight style on this entry.</p> <p>Supported values: - \"red\" (0) - \"yellow\" (1) - \"green\" (2) - \"blue\" (3) - \"purple\" (4) - \"grey\" (5) - \"strike\" (strike-through)</p> <p>Parameters:</p> Name Type Description Default <code>highlight</code> <code>str</code> <p>The highlight style to apply.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid highlight value is provided.</p> <code></code> add_request_header \u00b6 <pre><code>add_request_header(name: str, value: str) -&gt; None\n</code></pre> <p>Add or update a header in the request.</p> <code></code> add_response_header \u00b6 <pre><code>add_response_header(name: str, value: str) -&gt; None\n</code></pre> <p>Add or update a header in the response.</p> <code></code> set_response_content \u00b6 <pre><code>set_response_content(content: str) -&gt; None\n</code></pre> <p>Set the response body content.</p> <code></code> add_annotation \u00b6 <pre><code>add_annotation(annotation_type: str, content: str) -&gt; None\n</code></pre> <p>Add or update an annotation.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_type</code> <code>str</code> <p>The type/key of the annotation (e.g., \"digest\", \"dash-preview\")</p> required <code>content</code> <code>str</code> <p>The annotation content/value</p> required <code></code> remove_annotation \u00b6 <pre><code>remove_annotation(annotation_type: str) -&gt; None\n</code></pre> <p>Remove an annotation.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_type</code> <code>str</code> <p>The type/key of the annotation to remove</p> required"},{"location":"api/entries/#trace_shrink.entries.trace_entry-functions","title":"Functions","text":""},{"location":"api/entries/#trace_shrink.entries.TraceEntry","title":"trace_shrink.entries.TraceEntry","text":"<pre><code>TraceEntry(\n    index: int,\n    entry_id: str,\n    request: RequestDetails,\n    response: ResponseDetails,\n    timeline: TimelineDetails,\n    comment: Optional[str] = None,\n    highlight: Optional[str] = None,\n    annotations: Optional[Dict[str, str]] = None,\n)\n</code></pre> <p>Concrete model class for a single entry in a trace archive.</p>"},{"location":"api/entries/#trace_shrink.entries.TraceEntry-attributes","title":"Attributes","text":""},{"location":"api/entries/#trace_shrink.entries.TraceEntry.index","title":"index","text":"<pre><code>index: int\n</code></pre> <p>The zero-based index of the entry in the archive.</p>"},{"location":"api/entries/#trace_shrink.entries.TraceEntry.id","title":"id","text":"<pre><code>id: str\n</code></pre> <p>A unique identifier for the entry.</p>"},{"location":"api/entries/#trace_shrink.entries.TraceEntry.request","title":"request","text":"<pre><code>request: RequestDetails\n</code></pre> <p>Details of the HTTP request, with merged override headers.</p>"},{"location":"api/entries/#trace_shrink.entries.TraceEntry.response","title":"response","text":"<pre><code>response: ResponseDetails\n</code></pre> <p>Details of the HTTP response, with merged override headers.</p>"},{"location":"api/entries/#trace_shrink.entries.TraceEntry.timeline","title":"timeline","text":"<pre><code>timeline: TimelineDetails\n</code></pre> <p>Timeline details of the HTTP exchange.</p>"},{"location":"api/entries/#trace_shrink.entries.TraceEntry.comment","title":"comment","text":"<pre><code>comment: Optional[str]\n</code></pre> <p>An optional comment for the entry.</p>"},{"location":"api/entries/#trace_shrink.entries.TraceEntry.highlight","title":"highlight","text":"<pre><code>highlight: Optional[str]\n</code></pre> <p>An optional highlight style for the entry (e.g., 'red', 'yellow', 'strike').</p>"},{"location":"api/entries/#trace_shrink.entries.TraceEntry.annotations","title":"annotations","text":"<pre><code>annotations: Dict[str, str]\n</code></pre> <p>Return annotations dict, merging overrides with original annotations.</p> <p>Filters out None values (which represent removed annotations).</p>"},{"location":"api/entries/#trace_shrink.entries.TraceEntry.content","title":"content","text":"<pre><code>content: bytes | str\n</code></pre> <p>The content of the entry, extracted from the response body.</p>"},{"location":"api/entries/#trace_shrink.entries.TraceEntry.content_bytes","title":"content_bytes","text":"<pre><code>content_bytes: bytes\n</code></pre> <p>The content of the entry as bytes, converting strings if necessary.</p>"},{"location":"api/entries/#trace_shrink.entries.TraceEntry.format","title":"format","text":"<pre><code>format: Optional[Format]\n</code></pre> <p>The format of the entry (HLS, DASH, or None), determined from content type or URL.</p>"},{"location":"api/entries/#trace_shrink.entries.TraceEntry-functions","title":"Functions","text":""},{"location":"api/entries/#trace_shrink.entries.TraceEntry.set_comment","title":"set_comment","text":"<pre><code>set_comment(comment: str) -&gt; None\n</code></pre> <p>Set a comment on this entry.</p>"},{"location":"api/entries/#trace_shrink.entries.TraceEntry.set_highlight","title":"set_highlight","text":"<pre><code>set_highlight(highlight: str) -&gt; None\n</code></pre> <p>Set a highlight style on this entry.</p> <p>Supported values: - \"red\" (0) - \"yellow\" (1) - \"green\" (2) - \"blue\" (3) - \"purple\" (4) - \"grey\" (5) - \"strike\" (strike-through)</p> <p>Parameters:</p> Name Type Description Default <code>highlight</code> <code>str</code> <p>The highlight style to apply.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid highlight value is provided.</p>"},{"location":"api/entries/#trace_shrink.entries.TraceEntry.add_request_header","title":"add_request_header","text":"<pre><code>add_request_header(name: str, value: str) -&gt; None\n</code></pre> <p>Add or update a header in the request.</p>"},{"location":"api/entries/#trace_shrink.entries.TraceEntry.add_response_header","title":"add_response_header","text":"<pre><code>add_response_header(name: str, value: str) -&gt; None\n</code></pre> <p>Add or update a header in the response.</p>"},{"location":"api/entries/#trace_shrink.entries.TraceEntry.set_response_content","title":"set_response_content","text":"<pre><code>set_response_content(content: str) -&gt; None\n</code></pre> <p>Set the response body content.</p>"},{"location":"api/entries/#trace_shrink.entries.TraceEntry.add_annotation","title":"add_annotation","text":"<pre><code>add_annotation(annotation_type: str, content: str) -&gt; None\n</code></pre> <p>Add or update an annotation.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_type</code> <code>str</code> <p>The type/key of the annotation (e.g., \"digest\", \"dash-preview\")</p> required <code>content</code> <code>str</code> <p>The annotation content/value</p> required"},{"location":"api/entries/#trace_shrink.entries.TraceEntry.remove_annotation","title":"remove_annotation","text":"<pre><code>remove_annotation(annotation_type: str) -&gt; None\n</code></pre> <p>Remove an annotation.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_type</code> <code>str</code> <p>The type/key of the annotation to remove</p> required"},{"location":"api/entries/#trace_shrink.entries.HarEntry","title":"trace_shrink.entries.HarEntry","text":"<pre><code>HarEntry(har_entry_data: Dict[str, Any], reader: Any, entry_index: int)\n</code></pre> <p>               Bases: <code>TraceEntry</code></p> <p>Represents a single entry in a HAR file, providing access to request, response, and timeline details.</p> <p>Parameters:</p> Name Type Description Default <code>har_entry_data</code> <code>Dict[str, Any]</code> <p>The raw dictionary for the HAR entry.</p> required <code>reader</code> <code>Any</code> <p>The HarReader instance that this entry belongs to.</p> required <code>entry_index</code> <code>int</code> <p>The index of this entry within the HAR file.</p> required"},{"location":"api/entries/#trace_shrink.entries.HarEntry-attributes","title":"Attributes","text":""},{"location":"api/entries/#trace_shrink.entries.HarEntry.index","title":"index","text":"<pre><code>index: int\n</code></pre> <p>The zero-based index of the entry in the archive.</p>"},{"location":"api/entries/#trace_shrink.entries.HarEntry.id","title":"id","text":"<pre><code>id: str\n</code></pre> <p>A unique identifier for the entry.</p>"},{"location":"api/entries/#trace_shrink.entries.HarEntry.request","title":"request","text":"<pre><code>request: RequestDetails\n</code></pre> <p>Details of the HTTP request, with merged override headers.</p>"},{"location":"api/entries/#trace_shrink.entries.HarEntry.response","title":"response","text":"<pre><code>response: ResponseDetails\n</code></pre> <p>Details of the HTTP response, with merged override headers.</p>"},{"location":"api/entries/#trace_shrink.entries.HarEntry.timeline","title":"timeline","text":"<pre><code>timeline: TimelineDetails\n</code></pre> <p>Timeline details of the HTTP exchange.</p>"},{"location":"api/entries/#trace_shrink.entries.HarEntry.comment","title":"comment","text":"<pre><code>comment: Optional[str]\n</code></pre> <p>An optional comment for the entry.</p>"},{"location":"api/entries/#trace_shrink.entries.HarEntry.highlight","title":"highlight","text":"<pre><code>highlight: Optional[str]\n</code></pre> <p>An optional highlight style for the entry (e.g., 'red', 'yellow', 'strike').</p>"},{"location":"api/entries/#trace_shrink.entries.HarEntry.annotations","title":"annotations","text":"<pre><code>annotations: Dict[str, str]\n</code></pre> <p>Return annotations dict, merging overrides with original annotations.</p> <p>Filters out None values (which represent removed annotations).</p>"},{"location":"api/entries/#trace_shrink.entries.HarEntry.content","title":"content","text":"<pre><code>content: bytes | str\n</code></pre> <p>The content of the entry, extracted from the response body.</p>"},{"location":"api/entries/#trace_shrink.entries.HarEntry.content_bytes","title":"content_bytes","text":"<pre><code>content_bytes: bytes\n</code></pre> <p>The content of the entry as bytes, converting strings if necessary.</p>"},{"location":"api/entries/#trace_shrink.entries.HarEntry.format","title":"format","text":"<pre><code>format: Optional[Format]\n</code></pre> <p>The format of the entry (HLS, DASH, or None), determined from content type or URL.</p>"},{"location":"api/entries/#trace_shrink.entries.HarEntry.time","title":"time","text":"<pre><code>time: Optional[float]\n</code></pre> <p>Total time for the entry in milliseconds from the HAR spec.</p>"},{"location":"api/entries/#trace_shrink.entries.HarEntry-functions","title":"Functions","text":""},{"location":"api/entries/#trace_shrink.entries.HarEntry.set_comment","title":"set_comment","text":"<pre><code>set_comment(comment: str) -&gt; None\n</code></pre> <p>Set a comment on this entry.</p>"},{"location":"api/entries/#trace_shrink.entries.HarEntry.set_highlight","title":"set_highlight","text":"<pre><code>set_highlight(highlight: str) -&gt; None\n</code></pre> <p>Set a highlight style on this entry.</p> <p>Supported values: - \"red\" (0) - \"yellow\" (1) - \"green\" (2) - \"blue\" (3) - \"purple\" (4) - \"grey\" (5) - \"strike\" (strike-through)</p> <p>Parameters:</p> Name Type Description Default <code>highlight</code> <code>str</code> <p>The highlight style to apply.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid highlight value is provided.</p>"},{"location":"api/entries/#trace_shrink.entries.HarEntry.add_request_header","title":"add_request_header","text":"<pre><code>add_request_header(name: str, value: str) -&gt; None\n</code></pre> <p>Add or update a header in the request.</p>"},{"location":"api/entries/#trace_shrink.entries.HarEntry.add_response_header","title":"add_response_header","text":"<pre><code>add_response_header(name: str, value: str) -&gt; None\n</code></pre> <p>Add or update a header in the response.</p>"},{"location":"api/entries/#trace_shrink.entries.HarEntry.set_response_content","title":"set_response_content","text":"<pre><code>set_response_content(content: str) -&gt; None\n</code></pre> <p>Set the response body content.</p>"},{"location":"api/entries/#trace_shrink.entries.HarEntry.add_annotation","title":"add_annotation","text":"<pre><code>add_annotation(annotation_type: str, content: str) -&gt; None\n</code></pre> <p>Add or update an annotation.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_type</code> <code>str</code> <p>The type/key of the annotation (e.g., \"digest\", \"dash-preview\")</p> required <code>content</code> <code>str</code> <p>The annotation content/value</p> required"},{"location":"api/entries/#trace_shrink.entries.HarEntry.remove_annotation","title":"remove_annotation","text":"<pre><code>remove_annotation(annotation_type: str) -&gt; None\n</code></pre> <p>Remove an annotation.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_type</code> <code>str</code> <p>The type/key of the annotation to remove</p> required"},{"location":"api/entries/#trace_shrink.entries.HarEntry.get_raw_json","title":"get_raw_json","text":"<pre><code>get_raw_json() -&gt; Dict[str, Any]\n</code></pre> <p>Returns the raw JSON data for this entry.</p>"},{"location":"api/entries/#trace_shrink.entries.HarEntry.from_trace_entry","title":"from_trace_entry","text":"<pre><code>from_trace_entry(entry: TraceEntry, entry_index: int = 0) -&gt; Dict[str, Any]\n</code></pre> <p>Create a HAR entry dictionary from a TraceEntry.</p> <p>Parameters:</p> Name Type Description Default <code>entry</code> <code>TraceEntry</code> <p>The TraceEntry to convert.</p> required <code>entry_index</code> <code>int</code> <p>The index of the entry (for ID generation if needed).</p> <code>0</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary representing a HAR entry.</p>"},{"location":"api/entries/#trace_shrink.entries.MultiFileTraceEntry","title":"trace_shrink.entries.MultiFileTraceEntry","text":"<pre><code>MultiFileTraceEntry(\n    index: int,\n    exchange: Dict[str, Any],\n    body_bytes: Optional[bytes],\n    annotations: Optional[Dict[str, str]] = None,\n)\n</code></pre> <p>               Bases: <code>TraceEntry</code></p> <p>TraceEntry backed by a set of files produced by OutputStore.</p> <p>Expects a meta JSON dict like the one OutputStore writes, a body bytes object (or None), and optional annotations dict.</p>"},{"location":"api/entries/#trace_shrink.entries.MultiFileTraceEntry-attributes","title":"Attributes","text":""},{"location":"api/entries/#trace_shrink.entries.MultiFileTraceEntry.index","title":"index","text":"<pre><code>index: int\n</code></pre> <p>The zero-based index of the entry in the archive.</p>"},{"location":"api/entries/#trace_shrink.entries.MultiFileTraceEntry.id","title":"id","text":"<pre><code>id: str\n</code></pre> <p>A unique identifier for the entry.</p>"},{"location":"api/entries/#trace_shrink.entries.MultiFileTraceEntry.request","title":"request","text":"<pre><code>request: RequestDetails\n</code></pre> <p>Details of the HTTP request, with merged override headers.</p>"},{"location":"api/entries/#trace_shrink.entries.MultiFileTraceEntry.response","title":"response","text":"<pre><code>response: ResponseDetails\n</code></pre> <p>Details of the HTTP response, with merged override headers.</p>"},{"location":"api/entries/#trace_shrink.entries.MultiFileTraceEntry.timeline","title":"timeline","text":"<pre><code>timeline: TimelineDetails\n</code></pre> <p>Timeline details of the HTTP exchange.</p>"},{"location":"api/entries/#trace_shrink.entries.MultiFileTraceEntry.comment","title":"comment","text":"<pre><code>comment: Optional[str]\n</code></pre> <p>An optional comment for the entry.</p>"},{"location":"api/entries/#trace_shrink.entries.MultiFileTraceEntry.highlight","title":"highlight","text":"<pre><code>highlight: Optional[str]\n</code></pre> <p>An optional highlight style for the entry (e.g., 'red', 'yellow', 'strike').</p>"},{"location":"api/entries/#trace_shrink.entries.MultiFileTraceEntry.annotations","title":"annotations","text":"<pre><code>annotations: Dict[str, str]\n</code></pre> <p>Return annotations dict, merging overrides with original annotations.</p> <p>Filters out None values (which represent removed annotations).</p>"},{"location":"api/entries/#trace_shrink.entries.MultiFileTraceEntry.content","title":"content","text":"<pre><code>content: bytes | str\n</code></pre> <p>The content of the entry, extracted from the response body.</p>"},{"location":"api/entries/#trace_shrink.entries.MultiFileTraceEntry.content_bytes","title":"content_bytes","text":"<pre><code>content_bytes: bytes\n</code></pre> <p>The content of the entry as bytes, converting strings if necessary.</p>"},{"location":"api/entries/#trace_shrink.entries.MultiFileTraceEntry.format","title":"format","text":"<pre><code>format: Optional[Format]\n</code></pre> <p>The format of the entry (HLS, DASH, or None), determined from content type or URL.</p>"},{"location":"api/entries/#trace_shrink.entries.MultiFileTraceEntry-functions","title":"Functions","text":""},{"location":"api/entries/#trace_shrink.entries.MultiFileTraceEntry.set_comment","title":"set_comment","text":"<pre><code>set_comment(comment: str) -&gt; None\n</code></pre> <p>Set a comment on this entry.</p>"},{"location":"api/entries/#trace_shrink.entries.MultiFileTraceEntry.set_highlight","title":"set_highlight","text":"<pre><code>set_highlight(highlight: str) -&gt; None\n</code></pre> <p>Set a highlight style on this entry.</p> <p>Supported values: - \"red\" (0) - \"yellow\" (1) - \"green\" (2) - \"blue\" (3) - \"purple\" (4) - \"grey\" (5) - \"strike\" (strike-through)</p> <p>Parameters:</p> Name Type Description Default <code>highlight</code> <code>str</code> <p>The highlight style to apply.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid highlight value is provided.</p>"},{"location":"api/entries/#trace_shrink.entries.MultiFileTraceEntry.add_request_header","title":"add_request_header","text":"<pre><code>add_request_header(name: str, value: str) -&gt; None\n</code></pre> <p>Add or update a header in the request.</p>"},{"location":"api/entries/#trace_shrink.entries.MultiFileTraceEntry.add_response_header","title":"add_response_header","text":"<pre><code>add_response_header(name: str, value: str) -&gt; None\n</code></pre> <p>Add or update a header in the response.</p>"},{"location":"api/entries/#trace_shrink.entries.MultiFileTraceEntry.set_response_content","title":"set_response_content","text":"<pre><code>set_response_content(content: str) -&gt; None\n</code></pre> <p>Set the response body content.</p>"},{"location":"api/entries/#trace_shrink.entries.MultiFileTraceEntry.add_annotation","title":"add_annotation","text":"<pre><code>add_annotation(annotation_type: str, content: str) -&gt; None\n</code></pre> <p>Add or update an annotation.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_type</code> <code>str</code> <p>The type/key of the annotation (e.g., \"digest\", \"dash-preview\")</p> required <code>content</code> <code>str</code> <p>The annotation content/value</p> required"},{"location":"api/entries/#trace_shrink.entries.MultiFileTraceEntry.remove_annotation","title":"remove_annotation","text":"<pre><code>remove_annotation(annotation_type: str) -&gt; None\n</code></pre> <p>Remove an annotation.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_type</code> <code>str</code> <p>The type/key of the annotation to remove</p> required"},{"location":"api/entries/#trace_shrink.entries.MultiFileTraceEntry.from_files","title":"from_files","text":"<pre><code>from_files(\n    index: int,\n    meta_path: str,\n    body_path: str,\n    annotations_paths: Optional[List[str]] = None,\n)\n</code></pre>"},{"location":"api/entries/#trace_shrink.entries.ProxymanLogV2Entry","title":"trace_shrink.entries.ProxymanLogV2Entry","text":"<pre><code>ProxymanLogV2Entry(entry_name: str, raw_data: Dict[str, Any], reader: Any)\n</code></pre> <p>               Bases: <code>TraceEntry</code></p> <p>Represents a single request/response entry from a Proxyman log file. This class provides access to entry data according to the CaptureEntry interface.</p> <p>Parameters:</p> Name Type Description Default <code>entry_name</code> <code>str</code> <p>The internal filename or identifier for this entry in the archive.</p> required <code>raw_data</code> <code>Dict[str, Any]</code> <p>The dictionary containing the parsed JSON content of the entry.</p> required <code>reader</code> <code>Any</code> <p>The ProxymanLogV2Reader instance that this entry belongs to.</p> required"},{"location":"api/entries/#trace_shrink.entries.ProxymanLogV2Entry-attributes","title":"Attributes","text":""},{"location":"api/entries/#trace_shrink.entries.ProxymanLogV2Entry.index","title":"index","text":"<pre><code>index: int\n</code></pre> <p>The zero-based index of the entry in the archive.</p>"},{"location":"api/entries/#trace_shrink.entries.ProxymanLogV2Entry.id","title":"id","text":"<pre><code>id: str\n</code></pre> <p>A unique identifier for the entry.</p>"},{"location":"api/entries/#trace_shrink.entries.ProxymanLogV2Entry.request","title":"request","text":"<pre><code>request: RequestDetails\n</code></pre> <p>Details of the HTTP request, with merged override headers.</p>"},{"location":"api/entries/#trace_shrink.entries.ProxymanLogV2Entry.response","title":"response","text":"<pre><code>response: ResponseDetails\n</code></pre> <p>Details of the HTTP response, with merged override headers.</p>"},{"location":"api/entries/#trace_shrink.entries.ProxymanLogV2Entry.timeline","title":"timeline","text":"<pre><code>timeline: TimelineDetails\n</code></pre> <p>Timeline details of the HTTP exchange.</p>"},{"location":"api/entries/#trace_shrink.entries.ProxymanLogV2Entry.comment","title":"comment","text":"<pre><code>comment: Optional[str]\n</code></pre> <p>An optional comment for the entry.</p>"},{"location":"api/entries/#trace_shrink.entries.ProxymanLogV2Entry.highlight","title":"highlight","text":"<pre><code>highlight: Optional[str]\n</code></pre> <p>An optional highlight style for the entry (e.g., 'red', 'yellow', 'strike').</p>"},{"location":"api/entries/#trace_shrink.entries.ProxymanLogV2Entry.annotations","title":"annotations","text":"<pre><code>annotations: Dict[str, str]\n</code></pre> <p>Return annotations dict, merging overrides with original annotations.</p> <p>Filters out None values (which represent removed annotations).</p>"},{"location":"api/entries/#trace_shrink.entries.ProxymanLogV2Entry.content","title":"content","text":"<pre><code>content: bytes | str\n</code></pre> <p>The content of the entry, extracted from the response body.</p>"},{"location":"api/entries/#trace_shrink.entries.ProxymanLogV2Entry.content_bytes","title":"content_bytes","text":"<pre><code>content_bytes: bytes\n</code></pre> <p>The content of the entry as bytes, converting strings if necessary.</p>"},{"location":"api/entries/#trace_shrink.entries.ProxymanLogV2Entry.format","title":"format","text":"<pre><code>format: Optional[Format]\n</code></pre> <p>The format of the entry (HLS, DASH, or None), determined from content type or URL.</p>"},{"location":"api/entries/#trace_shrink.entries.ProxymanLogV2Entry-functions","title":"Functions","text":""},{"location":"api/entries/#trace_shrink.entries.ProxymanLogV2Entry.set_comment","title":"set_comment","text":"<pre><code>set_comment(comment: str) -&gt; None\n</code></pre> <p>Set a comment on this entry.</p>"},{"location":"api/entries/#trace_shrink.entries.ProxymanLogV2Entry.set_highlight","title":"set_highlight","text":"<pre><code>set_highlight(highlight: str) -&gt; None\n</code></pre> <p>Set a highlight style on this entry.</p> <p>Supported values: - \"red\" (0) - \"yellow\" (1) - \"green\" (2) - \"blue\" (3) - \"purple\" (4) - \"grey\" (5) - \"strike\" (strike-through)</p> <p>Parameters:</p> Name Type Description Default <code>highlight</code> <code>str</code> <p>The highlight style to apply.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid highlight value is provided.</p>"},{"location":"api/entries/#trace_shrink.entries.ProxymanLogV2Entry.add_request_header","title":"add_request_header","text":"<pre><code>add_request_header(name: str, value: str) -&gt; None\n</code></pre> <p>Add or update a header in the request.</p>"},{"location":"api/entries/#trace_shrink.entries.ProxymanLogV2Entry.add_response_header","title":"add_response_header","text":"<pre><code>add_response_header(name: str, value: str) -&gt; None\n</code></pre> <p>Add or update a header in the response.</p>"},{"location":"api/entries/#trace_shrink.entries.ProxymanLogV2Entry.set_response_content","title":"set_response_content","text":"<pre><code>set_response_content(content: str) -&gt; None\n</code></pre> <p>Set the response body content.</p>"},{"location":"api/entries/#trace_shrink.entries.ProxymanLogV2Entry.add_annotation","title":"add_annotation","text":"<pre><code>add_annotation(annotation_type: str, content: str) -&gt; None\n</code></pre> <p>Add or update an annotation.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_type</code> <code>str</code> <p>The type/key of the annotation (e.g., \"digest\", \"dash-preview\")</p> required <code>content</code> <code>str</code> <p>The annotation content/value</p> required"},{"location":"api/entries/#trace_shrink.entries.ProxymanLogV2Entry.remove_annotation","title":"remove_annotation","text":"<pre><code>remove_annotation(annotation_type: str) -&gt; None\n</code></pre> <p>Remove an annotation.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_type</code> <code>str</code> <p>The type/key of the annotation to remove</p> required"},{"location":"api/entries/#trace_shrink.entries.ProxymanLogV2Entry.get_raw_json","title":"get_raw_json","text":"<pre><code>get_raw_json() -&gt; Dict[str, Any]\n</code></pre> <p>Returns the raw, unmodified JSON data for this entry.</p>"},{"location":"api/entries/#trace_shrink.entries.ProxymanLogV2Entry.from_trace_entry","title":"from_trace_entry","text":"<pre><code>from_trace_entry(\n    entry: TraceEntry, index: int = 0\n) -&gt; Tuple[Dict[str, Any], str]\n</code></pre> <p>Create a Proxyman entry dictionary and filename from a TraceEntry.</p> <p>Parameters:</p> Name Type Description Default <code>entry</code> <code>TraceEntry</code> <p>The TraceEntry to convert.</p> required <code>index</code> <code>int</code> <p>The index of the entry (used in filename).</p> <code>0</code> <p>Returns:</p> Type Description <code>Tuple[Dict[str, Any], str]</code> <p>Tuple of (entry_data_dict, filename).</p>"},{"location":"api/entries/#trace_shrink.entries.BodyLoggerEntry","title":"trace_shrink.entries.BodyLoggerEntry","text":"<pre><code>BodyLoggerEntry(\n    index: int,\n    entry_id: str,\n    request: RequestDetails,\n    response: ResponseDetails,\n    timeline: TimelineDetails,\n    comment: Optional[str] = None,\n    highlight: Optional[str] = None,\n    annotations: Optional[Dict[str, str]] = None,\n)\n</code></pre> <p>               Bases: <code>TraceEntry</code></p> <p>Represents a single entry from a bodylogger file.</p> <p>This is a TraceEntry with bodylogger-specific properties for backward compatibility.</p>"},{"location":"api/entries/#trace_shrink.entries.BodyLoggerEntry-attributes","title":"Attributes","text":""},{"location":"api/entries/#trace_shrink.entries.BodyLoggerEntry.index","title":"index","text":"<pre><code>index: int\n</code></pre> <p>The zero-based index of the entry in the archive.</p>"},{"location":"api/entries/#trace_shrink.entries.BodyLoggerEntry.id","title":"id","text":"<pre><code>id: str\n</code></pre> <p>A unique identifier for the entry.</p>"},{"location":"api/entries/#trace_shrink.entries.BodyLoggerEntry.request","title":"request","text":"<pre><code>request: RequestDetails\n</code></pre> <p>Details of the HTTP request, with merged override headers.</p>"},{"location":"api/entries/#trace_shrink.entries.BodyLoggerEntry.response","title":"response","text":"<pre><code>response: ResponseDetails\n</code></pre> <p>Details of the HTTP response, with merged override headers.</p>"},{"location":"api/entries/#trace_shrink.entries.BodyLoggerEntry.timeline","title":"timeline","text":"<pre><code>timeline: TimelineDetails\n</code></pre> <p>Timeline details of the HTTP exchange.</p>"},{"location":"api/entries/#trace_shrink.entries.BodyLoggerEntry.comment","title":"comment","text":"<pre><code>comment: Optional[str]\n</code></pre> <p>An optional comment for the entry.</p>"},{"location":"api/entries/#trace_shrink.entries.BodyLoggerEntry.highlight","title":"highlight","text":"<pre><code>highlight: Optional[str]\n</code></pre> <p>An optional highlight style for the entry (e.g., 'red', 'yellow', 'strike').</p>"},{"location":"api/entries/#trace_shrink.entries.BodyLoggerEntry.annotations","title":"annotations","text":"<pre><code>annotations: Dict[str, str]\n</code></pre> <p>Return annotations dict, merging overrides with original annotations.</p> <p>Filters out None values (which represent removed annotations).</p>"},{"location":"api/entries/#trace_shrink.entries.BodyLoggerEntry.content","title":"content","text":"<pre><code>content: bytes | str\n</code></pre> <p>The content of the entry, extracted from the response body.</p>"},{"location":"api/entries/#trace_shrink.entries.BodyLoggerEntry.content_bytes","title":"content_bytes","text":"<pre><code>content_bytes: bytes\n</code></pre> <p>The content of the entry as bytes, converting strings if necessary.</p>"},{"location":"api/entries/#trace_shrink.entries.BodyLoggerEntry.format","title":"format","text":"<pre><code>format: Optional[Format]\n</code></pre> <p>The format of the entry (HLS, DASH, or None), determined from content type or URL.</p>"},{"location":"api/entries/#trace_shrink.entries.BodyLoggerEntry.service_id","title":"service_id","text":"<pre><code>service_id: Optional[str]\n</code></pre> <p>Return the service ID for this entry.</p>"},{"location":"api/entries/#trace_shrink.entries.BodyLoggerEntry.session_id","title":"session_id","text":"<pre><code>session_id: Optional[str]\n</code></pre> <p>Return the session ID for this entry.</p>"},{"location":"api/entries/#trace_shrink.entries.BodyLoggerEntry.correlation_id","title":"correlation_id","text":"<pre><code>correlation_id: int\n</code></pre> <p>Return the correlation ID for this entry.</p>"},{"location":"api/entries/#trace_shrink.entries.BodyLoggerEntry-functions","title":"Functions","text":""},{"location":"api/entries/#trace_shrink.entries.BodyLoggerEntry.set_comment","title":"set_comment","text":"<pre><code>set_comment(comment: str) -&gt; None\n</code></pre> <p>Set a comment on this entry.</p>"},{"location":"api/entries/#trace_shrink.entries.BodyLoggerEntry.set_highlight","title":"set_highlight","text":"<pre><code>set_highlight(highlight: str) -&gt; None\n</code></pre> <p>Set a highlight style on this entry.</p> <p>Supported values: - \"red\" (0) - \"yellow\" (1) - \"green\" (2) - \"blue\" (3) - \"purple\" (4) - \"grey\" (5) - \"strike\" (strike-through)</p> <p>Parameters:</p> Name Type Description Default <code>highlight</code> <code>str</code> <p>The highlight style to apply.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid highlight value is provided.</p>"},{"location":"api/entries/#trace_shrink.entries.BodyLoggerEntry.add_request_header","title":"add_request_header","text":"<pre><code>add_request_header(name: str, value: str) -&gt; None\n</code></pre> <p>Add or update a header in the request.</p>"},{"location":"api/entries/#trace_shrink.entries.BodyLoggerEntry.add_response_header","title":"add_response_header","text":"<pre><code>add_response_header(name: str, value: str) -&gt; None\n</code></pre> <p>Add or update a header in the response.</p>"},{"location":"api/entries/#trace_shrink.entries.BodyLoggerEntry.set_response_content","title":"set_response_content","text":"<pre><code>set_response_content(content: str) -&gt; None\n</code></pre> <p>Set the response body content.</p>"},{"location":"api/entries/#trace_shrink.entries.BodyLoggerEntry.add_annotation","title":"add_annotation","text":"<pre><code>add_annotation(annotation_type: str, content: str) -&gt; None\n</code></pre> <p>Add or update an annotation.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_type</code> <code>str</code> <p>The type/key of the annotation (e.g., \"digest\", \"dash-preview\")</p> required <code>content</code> <code>str</code> <p>The annotation content/value</p> required"},{"location":"api/entries/#trace_shrink.entries.BodyLoggerEntry.remove_annotation","title":"remove_annotation","text":"<pre><code>remove_annotation(annotation_type: str) -&gt; None\n</code></pre> <p>Remove an annotation.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_type</code> <code>str</code> <p>The type/key of the annotation to remove</p> required"},{"location":"api/entries/#trace_shrink.entries.BodyLoggerEntry.get_raw_data","title":"get_raw_data","text":"<pre><code>get_raw_data() -&gt; Dict[str, Any]\n</code></pre> <p>Returns the raw data for this entry.</p>"},{"location":"api/entries/#trace_shrink.entries.RequestsResponseTraceEntry","title":"trace_shrink.entries.RequestsResponseTraceEntry","text":"<pre><code>RequestsResponseTraceEntry(\n    response: \"Response\", index: int = 0, entry_id: Optional[str] = None\n)\n</code></pre> <p>               Bases: <code>TraceEntry</code></p> <p>TraceEntry adapter that wraps a requests.Response object.</p> <p>This class provides a TraceEntry interface for a requests.Response object, allowing it to be used with trace_shrink APIs that expect TraceEntry instances. Note: This is a read-only entry type (no corresponding Writer class), but mutations via the parent TraceEntry class are fully supported.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>'Response'</code> <p>The requests.Response object to wrap</p> required <code>index</code> <code>int</code> <p>The index of this entry (default: 0)</p> <code>0</code> <code>entry_id</code> <code>Optional[str]</code> <p>Optional unique identifier (default: str(index))</p> <code>None</code>"},{"location":"api/entries/#trace_shrink.entries.RequestsResponseTraceEntry-attributes","title":"Attributes","text":""},{"location":"api/entries/#trace_shrink.entries.RequestsResponseTraceEntry.index","title":"index","text":"<pre><code>index: int\n</code></pre> <p>The zero-based index of the entry in the archive.</p>"},{"location":"api/entries/#trace_shrink.entries.RequestsResponseTraceEntry.id","title":"id","text":"<pre><code>id: str\n</code></pre> <p>A unique identifier for the entry.</p>"},{"location":"api/entries/#trace_shrink.entries.RequestsResponseTraceEntry.request","title":"request","text":"<pre><code>request: RequestDetails\n</code></pre> <p>Details of the HTTP request, with merged override headers.</p>"},{"location":"api/entries/#trace_shrink.entries.RequestsResponseTraceEntry.response","title":"response","text":"<pre><code>response: ResponseDetails\n</code></pre> <p>Details of the HTTP response, with merged override headers.</p>"},{"location":"api/entries/#trace_shrink.entries.RequestsResponseTraceEntry.timeline","title":"timeline","text":"<pre><code>timeline: TimelineDetails\n</code></pre> <p>Timeline details of the HTTP exchange.</p>"},{"location":"api/entries/#trace_shrink.entries.RequestsResponseTraceEntry.comment","title":"comment","text":"<pre><code>comment: Optional[str]\n</code></pre> <p>An optional comment for the entry.</p>"},{"location":"api/entries/#trace_shrink.entries.RequestsResponseTraceEntry.highlight","title":"highlight","text":"<pre><code>highlight: Optional[str]\n</code></pre> <p>An optional highlight style for the entry (e.g., 'red', 'yellow', 'strike').</p>"},{"location":"api/entries/#trace_shrink.entries.RequestsResponseTraceEntry.annotations","title":"annotations","text":"<pre><code>annotations: Dict[str, str]\n</code></pre> <p>Return annotations dict, merging overrides with original annotations.</p> <p>Filters out None values (which represent removed annotations).</p>"},{"location":"api/entries/#trace_shrink.entries.RequestsResponseTraceEntry.content","title":"content","text":"<pre><code>content: bytes | str\n</code></pre> <p>The content of the entry, extracted from the response body.</p>"},{"location":"api/entries/#trace_shrink.entries.RequestsResponseTraceEntry.content_bytes","title":"content_bytes","text":"<pre><code>content_bytes: bytes\n</code></pre> <p>The content of the entry as bytes, converting strings if necessary.</p>"},{"location":"api/entries/#trace_shrink.entries.RequestsResponseTraceEntry.format","title":"format","text":"<pre><code>format: Optional[Format]\n</code></pre> <p>The format of the entry (HLS, DASH, or None), determined from content type or URL.</p>"},{"location":"api/entries/#trace_shrink.entries.RequestsResponseTraceEntry.elapsed_ms","title":"elapsed_ms","text":"<pre><code>elapsed_ms: int\n</code></pre> <p>Get the elapsed time in milliseconds from the response.</p>"},{"location":"api/entries/#trace_shrink.entries.RequestsResponseTraceEntry.reason","title":"reason","text":"<pre><code>reason: Optional[str]\n</code></pre> <p>Get the HTTP reason phrase from the response.</p>"},{"location":"api/entries/#trace_shrink.entries.RequestsResponseTraceEntry-functions","title":"Functions","text":""},{"location":"api/entries/#trace_shrink.entries.RequestsResponseTraceEntry.set_comment","title":"set_comment","text":"<pre><code>set_comment(comment: str) -&gt; None\n</code></pre> <p>Set a comment on this entry.</p>"},{"location":"api/entries/#trace_shrink.entries.RequestsResponseTraceEntry.set_highlight","title":"set_highlight","text":"<pre><code>set_highlight(highlight: str) -&gt; None\n</code></pre> <p>Set a highlight style on this entry.</p> <p>Supported values: - \"red\" (0) - \"yellow\" (1) - \"green\" (2) - \"blue\" (3) - \"purple\" (4) - \"grey\" (5) - \"strike\" (strike-through)</p> <p>Parameters:</p> Name Type Description Default <code>highlight</code> <code>str</code> <p>The highlight style to apply.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid highlight value is provided.</p>"},{"location":"api/entries/#trace_shrink.entries.RequestsResponseTraceEntry.add_request_header","title":"add_request_header","text":"<pre><code>add_request_header(name: str, value: str) -&gt; None\n</code></pre> <p>Add or update a header in the request.</p>"},{"location":"api/entries/#trace_shrink.entries.RequestsResponseTraceEntry.add_response_header","title":"add_response_header","text":"<pre><code>add_response_header(name: str, value: str) -&gt; None\n</code></pre> <p>Add or update a header in the response.</p>"},{"location":"api/entries/#trace_shrink.entries.RequestsResponseTraceEntry.set_response_content","title":"set_response_content","text":"<pre><code>set_response_content(content: str) -&gt; None\n</code></pre> <p>Set the response body content.</p>"},{"location":"api/entries/#trace_shrink.entries.RequestsResponseTraceEntry.add_annotation","title":"add_annotation","text":"<pre><code>add_annotation(annotation_type: str, content: str) -&gt; None\n</code></pre> <p>Add or update an annotation.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_type</code> <code>str</code> <p>The type/key of the annotation (e.g., \"digest\", \"dash-preview\")</p> required <code>content</code> <code>str</code> <p>The annotation content/value</p> required"},{"location":"api/entries/#trace_shrink.entries.RequestsResponseTraceEntry.remove_annotation","title":"remove_annotation","text":"<pre><code>remove_annotation(annotation_type: str) -&gt; None\n</code></pre> <p>Remove an annotation.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_type</code> <code>str</code> <p>The type/key of the annotation to remove</p> required"},{"location":"api/readers/","title":"Readers","text":""},{"location":"api/readers/#trace_shrinkreaders","title":"trace_shrink.readers","text":"<p>This page documents the trace readers available under <code>trace_shrink.readers</code>.</p> <p>Main exports</p> <ul> <li><code>HarReader</code>: load traces from HAR files.</li> <li><code>ProxymanLogV2Reader</code>: load traces from Proxyman Log v2 files.</li> <li><code>MultiFileFolderReader</code>: read traces stored in the multifile folder layout.</li> <li><code>BodyLoggerReader</code>: read traces from BodyLogger logs.</li> </ul> <p>Autogenerated API docs (from code)</p>"},{"location":"api/readers/#trace_shrink.readers","title":"trace_shrink.readers","text":"<p>Readers exposed by trace_shrink.readers</p> <p>Re-export the primary TraceReader implementations for convenience and documentation indexing.</p>"},{"location":"api/readers/#trace_shrink.readers-classes","title":"Classes","text":""},{"location":"api/readers/#trace_shrink.readers.BodyLoggerReader","title":"BodyLoggerReader","text":"<pre><code>BodyLoggerReader(log_file_path: str)\n</code></pre> <p>               Bases: <code>TraceReader</code></p> <p>Handles reading and indexing bodylogger log files.</p> <p>Parameters:</p> Name Type Description Default <code>log_file_path</code> <code>str</code> <p>The path to the bodylogger file.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the bodylogger file does not exist.</p> <code>RuntimeError</code> <p>For other unexpected errors during initialization.</p>"},{"location":"api/readers/#trace_shrink.readers.BodyLoggerReader-attributes","title":"Attributes","text":"trace \u00b6 <pre><code>trace: Trace\n</code></pre> <code></code> log_file_path \u00b6 <pre><code>log_file_path = log_file_path\n</code></pre>"},{"location":"api/readers/#trace_shrink.readers.BodyLoggerReader-functions","title":"Functions","text":"query \u00b6 <pre><code>query(\n    log_type: Optional[str] = None,\n    service_id: Optional[str] = None,\n    session_id: Optional[str] = None,\n    start_time: Optional[datetime] = None,\n    end_time: Optional[datetime] = None,\n) -&gt; List[BodyLoggerEntry]\n</code></pre> <p>Filters log entries based on the provided criteria.</p> <p>Parameters:</p> Name Type Description Default <code>log_type</code> <code>Optional[str]</code> <p>Filter by log type (e.g., \"REQUEST\", \"RESPONSE\").</p> <code>None</code> <code>service_id</code> <code>Optional[str]</code> <p>Filter by service ID.</p> <code>None</code> <code>session_id</code> <code>Optional[str]</code> <p>Filter by session ID.</p> <code>None</code> <code>start_time</code> <code>Optional[datetime]</code> <p>Filter by entries after or at this time.</p> <code>None</code> <code>end_time</code> <code>Optional[datetime]</code> <p>Filter by entries before or at this time.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[BodyLoggerEntry]</code> <p>A list of BodyLoggerEntry objects matching the criteria.</p>"},{"location":"api/readers/#trace_shrink.readers.HarReader","title":"HarReader","text":"<pre><code>HarReader(har_file_path: str)\n</code></pre> <p>               Bases: <code>TraceReader</code></p> <p>Handles reading and indexing HAR (HTTP Archive) files (.har).</p> <p>Parameters:</p> Name Type Description Default <code>har_file_path</code> <code>str</code> <p>The path to the .har file.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the HAR file does not exist.</p> <code>ValueError</code> <p>If the file content is not valid JSON or not a HAR structure.</p>"},{"location":"api/readers/#trace_shrink.readers.HarReader-attributes","title":"Attributes","text":"har_file_path \u00b6 <pre><code>har_file_path = har_file_path\n</code></pre> <code></code> trace \u00b6 <pre><code>trace: Trace\n</code></pre> <p>Lazy-load entries when trace is accessed.</p>"},{"location":"api/readers/#trace_shrink.readers.HarReader-functions","title":"Functions","text":"get_har_log_version \u00b6 <pre><code>get_har_log_version() -&gt; Optional[str]\n</code></pre> <code></code> get_har_creator_info \u00b6 <pre><code>get_har_creator_info() -&gt; Optional[Dict[str, Any]]\n</code></pre>"},{"location":"api/readers/#trace_shrink.readers.MultiFileFolderReader","title":"MultiFileFolderReader","text":"<pre><code>MultiFileFolderReader(path: str)\n</code></pre> <p>               Bases: <code>TraceReader</code></p> <p>TraceReader backed by a folder or .barc/.zip archive containing request_N.meta.json and request_N.body files.</p> <p>Supports both: - Directory path containing multifile format files - .barc or .zip archive containing multifile format files</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to either a directory or a .barc/.zip file</p> required"},{"location":"api/readers/#trace_shrink.readers.MultiFileFolderReader-attributes","title":"Attributes","text":"META_RE \u00b6 <pre><code>META_RE = compile('request_(\\\\d+)\\\\.meta\\\\.json$')\n</code></pre> <code></code> path \u00b6 <pre><code>path = path\n</code></pre> <code></code> trace \u00b6 <pre><code>trace: Trace\n</code></pre> <p>Lazy-load entries when trace is accessed.</p>"},{"location":"api/readers/#trace_shrink.readers.ProxymanLogV2Reader","title":"ProxymanLogV2Reader","text":"<pre><code>ProxymanLogV2Reader(log_file_path: str)\n</code></pre> <p>               Bases: <code>TraceReader</code></p> <p>Handles reading and indexing Proxyman log files (.proxymanlogv2). Ensures lazy loading of entry details.</p> <p>Parameters:</p> Name Type Description Default <code>log_file_path</code> <code>str</code> <p>The path to the .proxymanlogv2 file.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the log file does not exist.</p> <code>ValueError</code> <p>If the file is not a valid zip archive.</p> <code>RuntimeError</code> <p>For other unexpected errors during initialization.</p>"},{"location":"api/readers/#trace_shrink.readers.ProxymanLogV2Reader-attributes","title":"Attributes","text":"REQUEST_FILE_PATTERN \u00b6 <pre><code>REQUEST_FILE_PATTERN = compile('request_(\\\\d+)_([a-zA-Z0-9_-]+)')\n</code></pre> <code></code> log_file_path \u00b6 <pre><code>log_file_path = log_file_path\n</code></pre> <code></code> trace \u00b6 <pre><code>trace: Trace\n</code></pre> <p>Lazy-load entries when trace is accessed.</p>"},{"location":"api/readers/#trace_shrink.readers.ProxymanLogV2Reader-functions","title":"Functions","text":"get_index \u00b6 <pre><code>get_index() -&gt; Dict[str, Dict[str, Any]]\n</code></pre> <p>Returns the generated lightweight index.</p> <p>The index maps the internal filename (e.g., 'request_1_86') to a dictionary containing extracted metadata like 'id', 'index', 'host', and 'uri'. Host and URI might be None if the entry content was unreadable during indexing.</p>"},{"location":"api/readers/#trace_shrink.readers-modules","title":"Modules","text":""},{"location":"api/readers/#trace_shrink.readers.bodylogger_reader","title":"bodylogger_reader","text":""},{"location":"api/readers/#trace_shrink.readers.bodylogger_reader-classes","title":"Classes","text":"BodyLoggerReader \u00b6 <pre><code>BodyLoggerReader(log_file_path: str)\n</code></pre> <p>               Bases: <code>TraceReader</code></p> <p>Handles reading and indexing bodylogger log files.</p> <p>Parameters:</p> Name Type Description Default <code>log_file_path</code> <code>str</code> <p>The path to the bodylogger file.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the bodylogger file does not exist.</p> <code>RuntimeError</code> <p>For other unexpected errors during initialization.</p> Attributes\u00b6 <code></code> log_file_path \u00b6 <pre><code>log_file_path = log_file_path\n</code></pre> <code></code> trace \u00b6 <pre><code>trace: Trace\n</code></pre> Functions\u00b6 <code></code> query \u00b6 <pre><code>query(\n    log_type: Optional[str] = None,\n    service_id: Optional[str] = None,\n    session_id: Optional[str] = None,\n    start_time: Optional[datetime] = None,\n    end_time: Optional[datetime] = None,\n) -&gt; List[BodyLoggerEntry]\n</code></pre> <p>Filters log entries based on the provided criteria.</p> <p>Parameters:</p> Name Type Description Default <code>log_type</code> <code>Optional[str]</code> <p>Filter by log type (e.g., \"REQUEST\", \"RESPONSE\").</p> <code>None</code> <code>service_id</code> <code>Optional[str]</code> <p>Filter by service ID.</p> <code>None</code> <code>session_id</code> <code>Optional[str]</code> <p>Filter by session ID.</p> <code>None</code> <code>start_time</code> <code>Optional[datetime]</code> <p>Filter by entries after or at this time.</p> <code>None</code> <code>end_time</code> <code>Optional[datetime]</code> <p>Filter by entries before or at this time.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[BodyLoggerEntry]</code> <p>A list of BodyLoggerEntry objects matching the criteria.</p>"},{"location":"api/readers/#trace_shrink.readers.bodylogger_reader-functions","title":"Functions","text":""},{"location":"api/readers/#trace_shrink.readers.har_reader","title":"har_reader","text":""},{"location":"api/readers/#trace_shrink.readers.har_reader-classes","title":"Classes","text":"HarReader \u00b6 <pre><code>HarReader(har_file_path: str)\n</code></pre> <p>               Bases: <code>TraceReader</code></p> <p>Handles reading and indexing HAR (HTTP Archive) files (.har).</p> <p>Parameters:</p> Name Type Description Default <code>har_file_path</code> <code>str</code> <p>The path to the .har file.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the HAR file does not exist.</p> <code>ValueError</code> <p>If the file content is not valid JSON or not a HAR structure.</p> Attributes\u00b6 <code></code> har_file_path \u00b6 <pre><code>har_file_path = har_file_path\n</code></pre> <code></code> trace \u00b6 <pre><code>trace: Trace\n</code></pre> <p>Lazy-load entries when trace is accessed.</p> Functions\u00b6 <code></code> get_har_log_version \u00b6 <pre><code>get_har_log_version() -&gt; Optional[str]\n</code></pre> <code></code> get_har_creator_info \u00b6 <pre><code>get_har_creator_info() -&gt; Optional[Dict[str, Any]]\n</code></pre>"},{"location":"api/readers/#trace_shrink.readers.multifile_reader","title":"multifile_reader","text":""},{"location":"api/readers/#trace_shrink.readers.multifile_reader-classes","title":"Classes","text":"MultiFileFolderReader \u00b6 <pre><code>MultiFileFolderReader(path: str)\n</code></pre> <p>               Bases: <code>TraceReader</code></p> <p>TraceReader backed by a folder or .barc/.zip archive containing request_N.meta.json and request_N.body files.</p> <p>Supports both: - Directory path containing multifile format files - .barc or .zip archive containing multifile format files</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to either a directory or a .barc/.zip file</p> required Attributes\u00b6 <code></code> META_RE \u00b6 <pre><code>META_RE = compile('request_(\\\\d+)\\\\.meta\\\\.json$')\n</code></pre> <code></code> path \u00b6 <pre><code>path = path\n</code></pre> <code></code> trace \u00b6 <pre><code>trace: Trace\n</code></pre> <p>Lazy-load entries when trace is accessed.</p>"},{"location":"api/readers/#trace_shrink.readers.proxyman_log_reader","title":"proxyman_log_reader","text":""},{"location":"api/readers/#trace_shrink.readers.proxyman_log_reader-classes","title":"Classes","text":"ProxymanLogV2Reader \u00b6 <pre><code>ProxymanLogV2Reader(log_file_path: str)\n</code></pre> <p>               Bases: <code>TraceReader</code></p> <p>Handles reading and indexing Proxyman log files (.proxymanlogv2). Ensures lazy loading of entry details.</p> <p>Parameters:</p> Name Type Description Default <code>log_file_path</code> <code>str</code> <p>The path to the .proxymanlogv2 file.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the log file does not exist.</p> <code>ValueError</code> <p>If the file is not a valid zip archive.</p> <code>RuntimeError</code> <p>For other unexpected errors during initialization.</p> Attributes\u00b6 <code></code> REQUEST_FILE_PATTERN \u00b6 <pre><code>REQUEST_FILE_PATTERN = compile('request_(\\\\d+)_([a-zA-Z0-9_-]+)')\n</code></pre> <code></code> log_file_path \u00b6 <pre><code>log_file_path = log_file_path\n</code></pre> <code></code> trace \u00b6 <pre><code>trace: Trace\n</code></pre> <p>Lazy-load entries when trace is accessed.</p> Functions\u00b6 <code></code> get_index \u00b6 <pre><code>get_index() -&gt; Dict[str, Dict[str, Any]]\n</code></pre> <p>Returns the generated lightweight index.</p> <p>The index maps the internal filename (e.g., 'request_1_86') to a dictionary containing extracted metadata like 'id', 'index', 'host', and 'uri'. Host and URI might be None if the entry content was unreadable during indexing.</p>"},{"location":"api/readers/#trace_shrink.readers.trace_reader","title":"trace_reader","text":""},{"location":"api/readers/#trace_shrink.readers.trace_reader-classes","title":"Classes","text":"TraceReader \u00b6 <pre><code>TraceReader(trace: Optional[Trace] = None)\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Internal abstract base class for all trace readers (HAR, Proxyman, etc).</p> <p>This is an internal implementation detail. Users should use <code>open_trace(path)</code> which returns a <code>Trace</code> object directly.</p> Attributes\u00b6 <code></code> trace \u00b6 <pre><code>trace: Trace\n</code></pre>"},{"location":"api/readers/#trace_shrink.readers.HarReader","title":"trace_shrink.readers.HarReader","text":"<pre><code>HarReader(har_file_path: str)\n</code></pre> <p>               Bases: <code>TraceReader</code></p> <p>Handles reading and indexing HAR (HTTP Archive) files (.har).</p> <p>Parameters:</p> Name Type Description Default <code>har_file_path</code> <code>str</code> <p>The path to the .har file.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the HAR file does not exist.</p> <code>ValueError</code> <p>If the file content is not valid JSON or not a HAR structure.</p>"},{"location":"api/readers/#trace_shrink.readers.HarReader-attributes","title":"Attributes","text":""},{"location":"api/readers/#trace_shrink.readers.HarReader.har_file_path","title":"har_file_path","text":"<pre><code>har_file_path = har_file_path\n</code></pre>"},{"location":"api/readers/#trace_shrink.readers.HarReader.trace","title":"trace","text":"<pre><code>trace: Trace\n</code></pre> <p>Lazy-load entries when trace is accessed.</p>"},{"location":"api/readers/#trace_shrink.readers.HarReader-functions","title":"Functions","text":""},{"location":"api/readers/#trace_shrink.readers.HarReader.get_har_log_version","title":"get_har_log_version","text":"<pre><code>get_har_log_version() -&gt; Optional[str]\n</code></pre>"},{"location":"api/readers/#trace_shrink.readers.HarReader.get_har_creator_info","title":"get_har_creator_info","text":"<pre><code>get_har_creator_info() -&gt; Optional[Dict[str, Any]]\n</code></pre>"},{"location":"api/readers/#trace_shrink.readers.ProxymanLogV2Reader","title":"trace_shrink.readers.ProxymanLogV2Reader","text":"<pre><code>ProxymanLogV2Reader(log_file_path: str)\n</code></pre> <p>               Bases: <code>TraceReader</code></p> <p>Handles reading and indexing Proxyman log files (.proxymanlogv2). Ensures lazy loading of entry details.</p> <p>Parameters:</p> Name Type Description Default <code>log_file_path</code> <code>str</code> <p>The path to the .proxymanlogv2 file.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the log file does not exist.</p> <code>ValueError</code> <p>If the file is not a valid zip archive.</p> <code>RuntimeError</code> <p>For other unexpected errors during initialization.</p>"},{"location":"api/readers/#trace_shrink.readers.ProxymanLogV2Reader-attributes","title":"Attributes","text":""},{"location":"api/readers/#trace_shrink.readers.ProxymanLogV2Reader.REQUEST_FILE_PATTERN","title":"REQUEST_FILE_PATTERN","text":"<pre><code>REQUEST_FILE_PATTERN = compile('request_(\\\\d+)_([a-zA-Z0-9_-]+)')\n</code></pre>"},{"location":"api/readers/#trace_shrink.readers.ProxymanLogV2Reader.log_file_path","title":"log_file_path","text":"<pre><code>log_file_path = log_file_path\n</code></pre>"},{"location":"api/readers/#trace_shrink.readers.ProxymanLogV2Reader.trace","title":"trace","text":"<pre><code>trace: Trace\n</code></pre> <p>Lazy-load entries when trace is accessed.</p>"},{"location":"api/readers/#trace_shrink.readers.ProxymanLogV2Reader-functions","title":"Functions","text":""},{"location":"api/readers/#trace_shrink.readers.ProxymanLogV2Reader.get_index","title":"get_index","text":"<pre><code>get_index() -&gt; Dict[str, Dict[str, Any]]\n</code></pre> <p>Returns the generated lightweight index.</p> <p>The index maps the internal filename (e.g., 'request_1_86') to a dictionary containing extracted metadata like 'id', 'index', 'host', and 'uri'. Host and URI might be None if the entry content was unreadable during indexing.</p>"},{"location":"api/readers/#trace_shrink.readers.MultiFileFolderReader","title":"trace_shrink.readers.MultiFileFolderReader","text":"<pre><code>MultiFileFolderReader(path: str)\n</code></pre> <p>               Bases: <code>TraceReader</code></p> <p>TraceReader backed by a folder or .barc/.zip archive containing request_N.meta.json and request_N.body files.</p> <p>Supports both: - Directory path containing multifile format files - .barc or .zip archive containing multifile format files</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to either a directory or a .barc/.zip file</p> required"},{"location":"api/readers/#trace_shrink.readers.MultiFileFolderReader-attributes","title":"Attributes","text":""},{"location":"api/readers/#trace_shrink.readers.MultiFileFolderReader.META_RE","title":"META_RE","text":"<pre><code>META_RE = compile('request_(\\\\d+)\\\\.meta\\\\.json$')\n</code></pre>"},{"location":"api/readers/#trace_shrink.readers.MultiFileFolderReader.path","title":"path","text":"<pre><code>path = path\n</code></pre>"},{"location":"api/readers/#trace_shrink.readers.MultiFileFolderReader.trace","title":"trace","text":"<pre><code>trace: Trace\n</code></pre> <p>Lazy-load entries when trace is accessed.</p>"},{"location":"api/readers/#trace_shrink.readers.BodyLoggerReader","title":"trace_shrink.readers.BodyLoggerReader","text":"<pre><code>BodyLoggerReader(log_file_path: str)\n</code></pre> <p>               Bases: <code>TraceReader</code></p> <p>Handles reading and indexing bodylogger log files.</p> <p>Parameters:</p> Name Type Description Default <code>log_file_path</code> <code>str</code> <p>The path to the bodylogger file.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the bodylogger file does not exist.</p> <code>RuntimeError</code> <p>For other unexpected errors during initialization.</p>"},{"location":"api/readers/#trace_shrink.readers.BodyLoggerReader-attributes","title":"Attributes","text":""},{"location":"api/readers/#trace_shrink.readers.BodyLoggerReader.trace","title":"trace","text":"<pre><code>trace: Trace\n</code></pre>"},{"location":"api/readers/#trace_shrink.readers.BodyLoggerReader.log_file_path","title":"log_file_path","text":"<pre><code>log_file_path = log_file_path\n</code></pre>"},{"location":"api/readers/#trace_shrink.readers.BodyLoggerReader-functions","title":"Functions","text":""},{"location":"api/readers/#trace_shrink.readers.BodyLoggerReader.query","title":"query","text":"<pre><code>query(\n    log_type: Optional[str] = None,\n    service_id: Optional[str] = None,\n    session_id: Optional[str] = None,\n    start_time: Optional[datetime] = None,\n    end_time: Optional[datetime] = None,\n) -&gt; List[BodyLoggerEntry]\n</code></pre> <p>Filters log entries based on the provided criteria.</p> <p>Parameters:</p> Name Type Description Default <code>log_type</code> <code>Optional[str]</code> <p>Filter by log type (e.g., \"REQUEST\", \"RESPONSE\").</p> <code>None</code> <code>service_id</code> <code>Optional[str]</code> <p>Filter by service ID.</p> <code>None</code> <code>session_id</code> <code>Optional[str]</code> <p>Filter by session ID.</p> <code>None</code> <code>start_time</code> <code>Optional[datetime]</code> <p>Filter by entries after or at this time.</p> <code>None</code> <code>end_time</code> <code>Optional[datetime]</code> <p>Filter by entries before or at this time.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[BodyLoggerEntry]</code> <p>A list of BodyLoggerEntry objects matching the criteria.</p>"},{"location":"api/top-level/","title":"Top-level","text":""},{"location":"api/top-level/#trace_shrink","title":"trace_shrink","text":""},{"location":"api/top-level/#core","title":"Core","text":""},{"location":"api/top-level/#trace_shrink.open_trace","title":"trace_shrink.open_trace","text":""},{"location":"api/top-level/#trace_shrink.open_trace-classes","title":"Classes","text":""},{"location":"api/top-level/#trace_shrink.open_trace-functions","title":"Functions","text":""},{"location":"api/top-level/#trace_shrink.open_trace.detect_format","title":"detect_format","text":"<pre><code>detect_format(path: Union[str, Path]) -&gt; str\n</code></pre> <p>Detect the format of a trace file from its path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the trace file or directory (as string or Path object)</p> required <p>Returns:</p> Type Description <code>str</code> <p>Format string: \"har\", \"proxymanlogv2\", \"bodylogger\" (for .log files), or \"multifile\"</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the format cannot be determined from the path</p>"},{"location":"api/top-level/#trace_shrink.open_trace.open_trace","title":"open_trace","text":"<pre><code>open_trace(path: str) -&gt; Trace\n</code></pre> <p>Factory function to open a trace file and return a Trace object. Supports .har, .proxymanlogv2, .log (bodylogger), .barc, .zip files, and directories (multifile).</p> <p>The appropriate reader is used internally to load the file, but the returned Trace object is the primary interface for accessing entries, filtering them, extracting ManifestStream, etc.</p> <p>The returned Trace object will have 'path' and 'format' properties set.</p> <p>Raises ValueError for unknown/unsupported file formats.</p>"},{"location":"api/top-level/#trace_shrink.Trace","title":"trace_shrink.Trace","text":"<pre><code>Trace(\n    entries: Optional[Sequence[TraceEntry]] = None,\n    metadata: Optional[Dict[str, Any]] = None,\n)\n</code></pre> <p>Canonical in-memory container that holds trace metadata and entries.</p>"},{"location":"api/top-level/#trace_shrink.Trace-attributes","title":"Attributes","text":""},{"location":"api/top-level/#trace_shrink.Trace.metadata","title":"metadata","text":"<pre><code>metadata: Dict[str, Any] = metadata or {}\n</code></pre>"},{"location":"api/top-level/#trace_shrink.Trace.abr_detector","title":"abr_detector","text":"<pre><code>abr_detector: AbrDetector = AbrDetector()\n</code></pre>"},{"location":"api/top-level/#trace_shrink.Trace.entries","title":"entries","text":"<pre><code>entries: List[TraceEntry]\n</code></pre>"},{"location":"api/top-level/#trace_shrink.Trace.path","title":"path","text":"<pre><code>path: Optional[str]\n</code></pre> <p>The path to the trace file or directory.</p>"},{"location":"api/top-level/#trace_shrink.Trace.format","title":"format","text":"<pre><code>format: Optional[str]\n</code></pre> <p>The format of the trace file: 'har', 'proxymanlogv2', 'bodylogger', or 'multifile'.</p>"},{"location":"api/top-level/#trace_shrink.Trace-functions","title":"Functions","text":""},{"location":"api/top-level/#trace_shrink.Trace.append","title":"append","text":"<pre><code>append(entry: TraceEntry) -&gt; None\n</code></pre>"},{"location":"api/top-level/#trace_shrink.Trace.extend","title":"extend","text":"<pre><code>extend(entries: Iterable[TraceEntry]) -&gt; None\n</code></pre>"},{"location":"api/top-level/#trace_shrink.Trace.replace","title":"replace","text":"<pre><code>replace(index: int, entry: TraceEntry) -&gt; None\n</code></pre>"},{"location":"api/top-level/#trace_shrink.Trace.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre>"},{"location":"api/top-level/#trace_shrink.Trace.get_entry_by_id","title":"get_entry_by_id","text":"<pre><code>get_entry_by_id(entry_id: str) -&gt; Optional[TraceEntry]\n</code></pre>"},{"location":"api/top-level/#trace_shrink.Trace.get_next_entry_by_id","title":"get_next_entry_by_id","text":"<pre><code>get_next_entry_by_id(\n    entry_id: str, direction: int, n: int = 1\n) -&gt; Optional[TraceEntry]\n</code></pre> <p>Gets an entry relative to the entry with the given ID within its manifest stream.</p> <p>Parameters:</p> Name Type Description Default <code>entry_id</code> <code>str</code> <p>The ID of the reference entry</p> required <code>direction</code> <code>int</code> <p>Direction to move (positive for forward, negative for backward)</p> required <code>n</code> <code>int</code> <p>Number of steps to move (default: 1)</p> <code>1</code> <p>Returns:</p> Type Description <code>Optional[TraceEntry]</code> <p>The entry at the relative position, or None if not found</p>"},{"location":"api/top-level/#trace_shrink.Trace.get_entries_for_url","title":"get_entries_for_url","text":"<pre><code>get_entries_for_url(url: Union[str, URL]) -&gt; List[TraceEntry]\n</code></pre>"},{"location":"api/top-level/#trace_shrink.Trace.get_entries_by_path","title":"get_entries_by_path","text":"<pre><code>get_entries_by_path(path: str) -&gt; List[TraceEntry]\n</code></pre>"},{"location":"api/top-level/#trace_shrink.Trace.get_entries_by_ids","title":"get_entries_by_ids","text":"<pre><code>get_entries_by_ids(entry_ids: Sequence[str]) -&gt; List[TraceEntry]\n</code></pre>"},{"location":"api/top-level/#trace_shrink.Trace.get_entries_by_host","title":"get_entries_by_host","text":"<pre><code>get_entries_by_host(host: Optional[str]) -&gt; List[TraceEntry]\n</code></pre> <p>Retrieves all entries that match the specified host. Host matching is case-insensitive.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>Optional[str]</code> <p>The host string to match. Case-insensitive.   Pass None to match entries with no host.</p> required <p>Returns:</p> Type Description <code>List[TraceEntry]</code> <p>List of TraceEntry objects matching the host, in order of appearance.</p>"},{"location":"api/top-level/#trace_shrink.Trace.get_entries_for_partial_url","title":"get_entries_for_partial_url","text":"<pre><code>get_entries_for_partial_url(\n    url_pattern: Union[str, Pattern[str]],\n) -&gt; List[TraceEntry]\n</code></pre>"},{"location":"api/top-level/#trace_shrink.Trace.filter","title":"filter","text":"<pre><code>filter(\n    host: Optional[str] = None,\n    url: Optional[str] = None,\n    partial_url: Optional[str] = None,\n    mime_type: Optional[str] = None,\n) -&gt; List[TraceEntry]\n</code></pre>"},{"location":"api/top-level/#trace_shrink.Trace.get_manifest_stream","title":"get_manifest_stream","text":"<pre><code>get_manifest_stream(manifest_url: Union[str, URL]) -&gt; ManifestStream\n</code></pre>"},{"location":"api/top-level/#trace_shrink.Trace.get_abr_manifest_urls","title":"get_abr_manifest_urls","text":"<pre><code>get_abr_manifest_urls(\n    format: Optional[Union[str, Format]] = None,\n) -&gt; List[DecoratedUrl]\n</code></pre> <p>Get all ABR manifest URLs in the trace.</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>Optional[Union[str, Format]]</code> <p>Optional format filter (Format.HLS, Format.DASH, or string like \"hls\", \"dash\")</p> <code>None</code> <p>Returns:</p> Type Description <code>List[DecoratedUrl]</code> <p>List of DecoratedUrl objects containing manifest URLs and their formats</p>"},{"location":"api/top-level/#trace_shrink.ManifestStream","title":"trace_shrink.ManifestStream","text":"<pre><code>ManifestStream(entries: List[TraceEntry])\n</code></pre> <p>Represents and manages a single, continuous stream of manifest entries from a trace, sorted by time.</p> <p>efficient time-based lookups.</p> <p>Parameters:</p> Name Type Description Default <code>entries</code> <code>List[TraceEntry]</code> <p>A list of TraceEntry objects for a single manifest URL.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the list of entries is empty.</p>"},{"location":"api/top-level/#trace_shrink.ManifestStream-attributes","title":"Attributes","text":""},{"location":"api/top-level/#trace_shrink.ManifestStream.entries","title":"entries","text":"<pre><code>entries = sorted(entries, key=_normalize_timestamp)\n</code></pre>"},{"location":"api/top-level/#trace_shrink.ManifestStream.timestamps","title":"timestamps","text":"<pre><code>timestamps = [(_normalize_timestamp(entry)) for entry in (entries)]\n</code></pre>"},{"location":"api/top-level/#trace_shrink.ManifestStream.format","title":"format","text":"<pre><code>format = from_url_or_mime_type(mime_type, url)\n</code></pre>"},{"location":"api/top-level/#trace_shrink.ManifestStream-functions","title":"Functions","text":""},{"location":"api/top-level/#trace_shrink.ManifestStream.get_original_path","title":"get_original_path","text":"<pre><code>get_original_path() -&gt; str\n</code></pre> <p>Get the original path of the manifest.</p>"},{"location":"api/top-level/#trace_shrink.ManifestStream.find_entry_by_time","title":"find_entry_by_time","text":"<pre><code>find_entry_by_time(\n    target_time: datetime,\n    position: Literal[\"nearest\", \"before\", \"after\"] = \"nearest\",\n    tolerance: float = 0.0,\n) -&gt; Optional[TraceEntry]\n</code></pre> <p>Finds an entry based on a target time, with tolerance and positioning.</p> <p>The logic is as follows: 1. It first searches for entries within the <code>target_time</code> +/- <code>tolerance</code>.    If any are found, it returns the one closest to the <code>target_time</code>. 2. If no entries are found within the tolerance, it uses the <code>position</code>    argument to find an entry from the entire stream.</p> <p>Parameters:</p> Name Type Description Default <code>target_time</code> <code>datetime</code> <p>The datetime to search for.</p> required <code>position</code> <code>Literal['nearest', 'before', 'after']</code> <p>Determines which entry to select if no match is found       within the tolerance. Can be \"nearest\", \"before\", or \"after\".</p> <code>'nearest'</code> <code>tolerance</code> <code>float</code> <p>A float in seconds to create a search window around the        target_time.</p> <code>0.0</code> <p>Returns:</p> Type Description <code>Optional[TraceEntry]</code> <p>A TraceEntry or None if no suitable entry is found.</p>"},{"location":"api/top-level/#trace_shrink.ManifestStream.get_relative_entry","title":"get_relative_entry","text":"<pre><code>get_relative_entry(\n    entry: TraceEntry, direction: int, n: int = 1\n) -&gt; Optional[TraceEntry]\n</code></pre> <p>Gets the nth entry relative to the given entry in this manifest stream.</p> <p>Parameters:</p> Name Type Description Default <code>entry</code> <code>TraceEntry</code> <p>The reference entry to navigate from.</p> required <code>direction</code> <code>int</code> <p>1 for forward (next), -1 for backward (previous).</p> required <code>n</code> <code>int</code> <p>Number of entries to skip (default: 1).</p> <code>1</code> <p>Returns:</p> Type Description <code>Optional[TraceEntry]</code> <p>The TraceEntry at the calculated position, or None if:</p> <code>Optional[TraceEntry]</code> <ul> <li>The entry is not found in this stream</li> </ul> <code>Optional[TraceEntry]</code> <ul> <li>The calculated position is out of bounds</li> </ul> <p>Examples:</p> <p>get_relative_entry(entry, 1, 1)  # Next entry get_relative_entry(entry, -1, 1)  # Previous entry get_relative_entry(entry, 1, 3)  # 3rd next entry</p>"},{"location":"api/top-level/#formats","title":"Formats","text":""},{"location":"api/top-level/#trace_shrink.detect_format","title":"trace_shrink.detect_format","text":"<pre><code>detect_format(path: Union[str, Path]) -&gt; str\n</code></pre> <p>Detect the format of a trace file from its path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the trace file or directory (as string or Path object)</p> required <p>Returns:</p> Type Description <code>str</code> <p>Format string: \"har\", \"proxymanlogv2\", \"bodylogger\" (for .log files), or \"multifile\"</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the format cannot be determined from the path</p>"},{"location":"api/top-level/#trace_shrink.utils.formats","title":"trace_shrink.utils.formats","text":""},{"location":"api/top-level/#trace_shrink.utils.formats-classes","title":"Classes","text":""},{"location":"api/top-level/#trace_shrink.utils.formats.Format","title":"Format","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/top-level/#trace_shrink.utils.formats.Format-attributes","title":"Attributes","text":"HLS \u00b6 <pre><code>HLS = 'HLS'\n</code></pre> <code></code> DASH \u00b6 <pre><code>DASH = 'DASH'\n</code></pre>"},{"location":"api/top-level/#trace_shrink.utils.formats.Format-functions","title":"Functions","text":"to_extension \u00b6 <pre><code>to_extension() -&gt; str\n</code></pre> <p>Get file extension for this format.</p> <p>Returns:</p> Type Description <code>str</code> <p>Extension string with leading dot (e.g., \".m3u8\", \".mpd\")</p> <code></code> from_extension \u00b6 <pre><code>from_extension(extension: str) -&gt; Optional[Format]\n</code></pre> <code></code> from_mime_type \u00b6 <pre><code>from_mime_type(mime_type: str) -&gt; Optional[Format]\n</code></pre> <code></code> from_url \u00b6 <pre><code>from_url(url: URL) -&gt; Optional[Format]\n</code></pre> <code></code> from_path \u00b6 <pre><code>from_path(url_path: str) -&gt; Optional[Format]\n</code></pre> <code></code> from_url_or_mime_type \u00b6 <pre><code>from_url_or_mime_type(mime_type: str, url: URL) -&gt; Optional[Format]\n</code></pre>"},{"location":"api/top-level/#trace_shrink.utils.formats.MimeType","title":"MimeType","text":"<pre><code>MimeType(mime_type: str)\n</code></pre>"},{"location":"api/top-level/#trace_shrink.utils.formats.MimeType-attributes","title":"Attributes","text":"MIME_TYPES \u00b6 <pre><code>MIME_TYPES = {\n    HLS: [\n        \"application/vnd.apple.mpegurl\",\n        \"application/x-mpegurl\",\n        \"application/x-mpegURL\",\n    ],\n    DASH: [\"application/dash+xml\", \"application/dash-xml\"],\n}\n</code></pre> <code></code> mime_type \u00b6 <pre><code>mime_type = strip()\n</code></pre>"},{"location":"api/top-level/#trace_shrink.utils.formats.MimeType-functions","title":"Functions","text":"is_format \u00b6 <pre><code>is_format(format: Format) -&gt; bool\n</code></pre> <code></code> is_dash \u00b6 <pre><code>is_dash() -&gt; bool\n</code></pre> <code></code> is_hls \u00b6 <pre><code>is_hls() -&gt; bool\n</code></pre> <code></code> is_abr_manifest \u00b6 <pre><code>is_abr_manifest() -&gt; bool\n</code></pre> <code></code> has_text_content \u00b6 <pre><code>has_text_content() -&gt; bool\n</code></pre> <code></code> to_format \u00b6 <pre><code>to_format() -&gt; Optional[Format]\n</code></pre>"},{"location":"api/top-level/#trace_shrink.utils.formats-functions","title":"Functions","text":""},{"location":"api/top-level/#trace_shrink.utils.formats.get_extension_for_entry","title":"get_extension_for_entry","text":"<pre><code>get_extension_for_entry(entry: 'TraceEntry') -&gt; str\n</code></pre> <p>Get file extension for a TraceEntry.</p> <p>Tries content-type/mime-type first, then falls back to URL extension.</p> <p>Parameters:</p> Name Type Description Default <code>entry</code> <code>'TraceEntry'</code> <p>The TraceEntry to get extension for</p> required <p>Returns:</p> Type Description <code>str</code> <p>Extension string with leading dot (e.g., \".m3u8\", \".mpd\") or empty string if unknown</p>"},{"location":"api/top-level/#export","title":"Export","text":""},{"location":"api/top-level/#trace_shrink.Exporter","title":"trace_shrink.Exporter","text":"<pre><code>Exporter(source: Trace)\n</code></pre> <p>Exports entries to different formats (HAR, Proxyman, etc.).</p> <p>The exporter works with any list of TraceEntry objects and converts them using the unified TraceEntry interface.</p> <p>Can be used as class methods for direct export, or instantiated with a Trace for convenience when exporting all entries.</p> <p>Examples:</p>"},{"location":"api/top-level/#trace_shrink.Exporter--as-class-method-entries-required","title":"As class method (entries required)","text":"<p>Exporter.to_har(\"output.har\", entries)</p>"},{"location":"api/top-level/#trace_shrink.Exporter--as-instance-method-entries-optional-defaults-to-all-trace-entries","title":"As instance method (entries optional, defaults to all trace entries)","text":"<p>exporter = Exporter(trace) exporter.to_har(\"output.har\")  # Exports all entries exporter.to_har(\"output.har\", filtered_entries)  # Exports specific entries</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Trace</code> <p>The Trace instance to export from.</p> required"},{"location":"api/top-level/#trace_shrink.Exporter-attributes","title":"Attributes","text":""},{"location":"api/top-level/#trace_shrink.Exporter.to_har","title":"to_har","text":"<pre><code>to_har = _ExportMethod(write)\n</code></pre>"},{"location":"api/top-level/#trace_shrink.Exporter.to_proxyman","title":"to_proxyman","text":"<pre><code>to_proxyman = _ExportMethod(write)\n</code></pre>"},{"location":"api/top-level/#trace_shrink.Exporter.to_multifile","title":"to_multifile","text":"<pre><code>to_multifile = _ExportMethod(write)\n</code></pre>"},{"location":"api/writers/","title":"Writers","text":""},{"location":"api/writers/#trace_shrinkwriters","title":"trace_shrink.writers","text":"<p>This page documents the writer implementations available under <code>trace_shrink.writers</code>.</p> <p>Main exports</p> <ul> <li><code>HarWriter</code>: export traces into a HAR file/dictionary.</li> <li><code>ProxymanWriter</code>: export traces into Proxyman log format.</li> <li><code>MultiFileWriter</code>: export traces into the multifile folder layout (meta.json + body files).</li> </ul> <p>Autogenerated API docs (from code)</p> <p>Import</p>"},{"location":"api/writers/#trace_shrink.writers","title":"trace_shrink.writers","text":"<p>Writers exposed by trace_shrink.writers</p> <p>Re-export writer classes used for exporting traces to different formats.</p>"},{"location":"api/writers/#trace_shrink.writers-classes","title":"Classes","text":""},{"location":"api/writers/#trace_shrink.writers.HarWriter","title":"HarWriter","text":"<p>Writer for HAR (HTTP Archive) format files.</p>"},{"location":"api/writers/#trace_shrink.writers.HarWriter-functions","title":"Functions","text":"write \u00b6 <pre><code>write(entries: List[TraceEntry], output_path: str) -&gt; None\n</code></pre> <p>Write a list of TraceEntry objects to a HAR file.</p> <p>Parameters:</p> Name Type Description Default <code>entries</code> <code>List[TraceEntry]</code> <p>List of TraceEntry objects to export.</p> required <code>output_path</code> <code>str</code> <p>Path where the HAR file will be written.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If the file cannot be written.</p>"},{"location":"api/writers/#trace_shrink.writers.MultiFileWriter","title":"MultiFileWriter","text":"<pre><code>MultiFileWriter(folder: str | Path)\n</code></pre> <p>Writer for multifile trace format.</p> <p>Writes trace entries to a folder with the following structure: - request_{index:06d}.meta.json - request_{index:06d}.body{extension} - request_{index:06d}.{annotation_name}.txt</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str | Path</code> <p>Path to the folder where files will be written</p> required"},{"location":"api/writers/#trace_shrink.writers.MultiFileWriter-attributes","title":"Attributes","text":"folder_path \u00b6 <pre><code>folder_path = Path(folder)\n</code></pre>"},{"location":"api/writers/#trace_shrink.writers.MultiFileWriter-functions","title":"Functions","text":"write \u00b6 <pre><code>write(entries: List[TraceEntry], output_path: str) -&gt; None\n</code></pre> <p>Write a list of TraceEntry objects to a multifile folder.</p> <p>Parameters:</p> Name Type Description Default <code>entries</code> <code>List[TraceEntry]</code> <p>List of TraceEntry objects to export.</p> required <code>output_path</code> <code>str</code> <p>Folder path where multifile artifacts will be written.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If the folder cannot be created or files cannot be written.</p> <code></code> add_entry \u00b6 <pre><code>add_entry(\n    entry: TraceEntry, index: int, body_bytes: Optional[bytes] = None\n) -&gt; None\n</code></pre> <p>Add a trace entry to the multifile archive.</p> <p>Files written: - request_{index:06d}.meta.json - request_{index:06d}.body{extension} (extension determined from content-type) - request_{index:06d}.{name}.txt for each annotation</p> <p>Parameters:</p> Name Type Description Default <code>entry</code> <code>TraceEntry</code> <p>TraceEntry object to write</p> required <code>index</code> <code>int</code> <p>Request index number (will be zero-padded to 6 digits)</p> required <code>body_bytes</code> <code>Optional[bytes]</code> <p>Optional body content as bytes (if not provided, extracted from entry)</p> <code>None</code>"},{"location":"api/writers/#trace_shrink.writers.ProxymanWriter","title":"ProxymanWriter","text":"<p>Writer for Proxyman log v2 format files.</p>"},{"location":"api/writers/#trace_shrink.writers.ProxymanWriter-functions","title":"Functions","text":"write \u00b6 <pre><code>write(entries: List[TraceEntry], output_path: str) -&gt; None\n</code></pre> <p>Write a list of TraceEntry objects to a Proxyman log v2 file.</p> <p>Parameters:</p> Name Type Description Default <code>entries</code> <code>List[TraceEntry]</code> <p>List of TraceEntry objects to export.</p> required <code>output_path</code> <code>str</code> <p>Path where the Proxyman log file will be written.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If the file cannot be written.</p>"},{"location":"api/writers/#trace_shrink.writers-modules","title":"Modules","text":""},{"location":"api/writers/#trace_shrink.writers.har_writer","title":"har_writer","text":"<p>HAR writer for exporting TraceEntry objects to HAR format.</p>"},{"location":"api/writers/#trace_shrink.writers.har_writer-classes","title":"Classes","text":"HarWriter \u00b6 <p>Writer for HAR (HTTP Archive) format files.</p> Functions\u00b6 write \u00b6 <pre><code>write(entries: List[TraceEntry], output_path: str) -&gt; None\n</code></pre> <p>Write a list of TraceEntry objects to a HAR file.</p> <p>Parameters:</p> Name Type Description Default <code>entries</code> <code>List[TraceEntry]</code> <p>List of TraceEntry objects to export.</p> required <code>output_path</code> <code>str</code> <p>Path where the HAR file will be written.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If the file cannot be written.</p>"},{"location":"api/writers/#trace_shrink.writers.har_writer-functions","title":"Functions","text":""},{"location":"api/writers/#trace_shrink.writers.multifile_writer","title":"multifile_writer","text":""},{"location":"api/writers/#trace_shrink.writers.multifile_writer-classes","title":"Classes","text":"MultiFileWriter \u00b6 <pre><code>MultiFileWriter(folder: str | Path)\n</code></pre> <p>Writer for multifile trace format.</p> <p>Writes trace entries to a folder with the following structure: - request_{index:06d}.meta.json - request_{index:06d}.body{extension} - request_{index:06d}.{annotation_name}.txt</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str | Path</code> <p>Path to the folder where files will be written</p> required Attributes\u00b6 <code></code> folder_path \u00b6 <pre><code>folder_path = Path(folder)\n</code></pre> Functions\u00b6 <code></code> write \u00b6 <pre><code>write(entries: List[TraceEntry], output_path: str) -&gt; None\n</code></pre> <p>Write a list of TraceEntry objects to a multifile folder.</p> <p>Parameters:</p> Name Type Description Default <code>entries</code> <code>List[TraceEntry]</code> <p>List of TraceEntry objects to export.</p> required <code>output_path</code> <code>str</code> <p>Folder path where multifile artifacts will be written.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If the folder cannot be created or files cannot be written.</p> <code></code> add_entry \u00b6 <pre><code>add_entry(\n    entry: TraceEntry, index: int, body_bytes: Optional[bytes] = None\n) -&gt; None\n</code></pre> <p>Add a trace entry to the multifile archive.</p> <p>Files written: - request_{index:06d}.meta.json - request_{index:06d}.body{extension} (extension determined from content-type) - request_{index:06d}.{name}.txt for each annotation</p> <p>Parameters:</p> Name Type Description Default <code>entry</code> <code>TraceEntry</code> <p>TraceEntry object to write</p> required <code>index</code> <code>int</code> <p>Request index number (will be zero-padded to 6 digits)</p> required <code>body_bytes</code> <code>Optional[bytes]</code> <p>Optional body content as bytes (if not provided, extracted from entry)</p> <code>None</code>"},{"location":"api/writers/#trace_shrink.writers.multifile_writer-functions","title":"Functions","text":"entry_to_exchange \u00b6 <pre><code>entry_to_exchange(entry: TraceEntry) -&gt; Dict\n</code></pre> <p>Convert a TraceEntry to an exchange dictionary for multifile format.</p> <p>Parameters:</p> Name Type Description Default <code>entry</code> <code>TraceEntry</code> <p>The TraceEntry to convert</p> required <p>Returns:</p> Type Description <code>Dict</code> <p>Dictionary representing the exchange in multifile format</p>"},{"location":"api/writers/#trace_shrink.writers.proxyman_writer","title":"proxyman_writer","text":"<p>Proxyman writer for exporting TraceEntry objects to Proxyman log v2 format.</p>"},{"location":"api/writers/#trace_shrink.writers.proxyman_writer-classes","title":"Classes","text":"ProxymanWriter \u00b6 <p>Writer for Proxyman log v2 format files.</p> Functions\u00b6 write \u00b6 <pre><code>write(entries: List[TraceEntry], output_path: str) -&gt; None\n</code></pre> <p>Write a list of TraceEntry objects to a Proxyman log v2 file.</p> <p>Parameters:</p> Name Type Description Default <code>entries</code> <code>List[TraceEntry]</code> <p>List of TraceEntry objects to export.</p> required <code>output_path</code> <code>str</code> <p>Path where the Proxyman log file will be written.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If the file cannot be written.</p>"},{"location":"api/writers/#trace_shrink.writers.HarWriter","title":"trace_shrink.writers.HarWriter","text":"<p>Writer for HAR (HTTP Archive) format files.</p>"},{"location":"api/writers/#trace_shrink.writers.HarWriter-functions","title":"Functions","text":""},{"location":"api/writers/#trace_shrink.writers.HarWriter.write","title":"write","text":"<pre><code>write(entries: List[TraceEntry], output_path: str) -&gt; None\n</code></pre> <p>Write a list of TraceEntry objects to a HAR file.</p> <p>Parameters:</p> Name Type Description Default <code>entries</code> <code>List[TraceEntry]</code> <p>List of TraceEntry objects to export.</p> required <code>output_path</code> <code>str</code> <p>Path where the HAR file will be written.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If the file cannot be written.</p>"},{"location":"api/writers/#trace_shrink.writers.ProxymanWriter","title":"trace_shrink.writers.ProxymanWriter","text":"<p>Writer for Proxyman log v2 format files.</p>"},{"location":"api/writers/#trace_shrink.writers.ProxymanWriter-functions","title":"Functions","text":""},{"location":"api/writers/#trace_shrink.writers.ProxymanWriter.write","title":"write","text":"<pre><code>write(entries: List[TraceEntry], output_path: str) -&gt; None\n</code></pre> <p>Write a list of TraceEntry objects to a Proxyman log v2 file.</p> <p>Parameters:</p> Name Type Description Default <code>entries</code> <code>List[TraceEntry]</code> <p>List of TraceEntry objects to export.</p> required <code>output_path</code> <code>str</code> <p>Path where the Proxyman log file will be written.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If the file cannot be written.</p>"},{"location":"api/writers/#trace_shrink.writers.MultiFileWriter","title":"trace_shrink.writers.MultiFileWriter","text":"<pre><code>MultiFileWriter(folder: str | Path)\n</code></pre> <p>Writer for multifile trace format.</p> <p>Writes trace entries to a folder with the following structure: - request_{index:06d}.meta.json - request_{index:06d}.body{extension} - request_{index:06d}.{annotation_name}.txt</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str | Path</code> <p>Path to the folder where files will be written</p> required"},{"location":"api/writers/#trace_shrink.writers.MultiFileWriter-attributes","title":"Attributes","text":""},{"location":"api/writers/#trace_shrink.writers.MultiFileWriter.folder_path","title":"folder_path","text":"<pre><code>folder_path = Path(folder)\n</code></pre>"},{"location":"api/writers/#trace_shrink.writers.MultiFileWriter-functions","title":"Functions","text":""},{"location":"api/writers/#trace_shrink.writers.MultiFileWriter.write","title":"write","text":"<pre><code>write(entries: List[TraceEntry], output_path: str) -&gt; None\n</code></pre> <p>Write a list of TraceEntry objects to a multifile folder.</p> <p>Parameters:</p> Name Type Description Default <code>entries</code> <code>List[TraceEntry]</code> <p>List of TraceEntry objects to export.</p> required <code>output_path</code> <code>str</code> <p>Folder path where multifile artifacts will be written.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If the folder cannot be created or files cannot be written.</p>"},{"location":"api/writers/#trace_shrink.writers.MultiFileWriter.add_entry","title":"add_entry","text":"<pre><code>add_entry(\n    entry: TraceEntry, index: int, body_bytes: Optional[bytes] = None\n) -&gt; None\n</code></pre> <p>Add a trace entry to the multifile archive.</p> <p>Files written: - request_{index:06d}.meta.json - request_{index:06d}.body{extension} (extension determined from content-type) - request_{index:06d}.{name}.txt for each annotation</p> <p>Parameters:</p> Name Type Description Default <code>entry</code> <code>TraceEntry</code> <p>TraceEntry object to write</p> required <code>index</code> <code>int</code> <p>Request index number (will be zero-padded to 6 digits)</p> required <code>body_bytes</code> <code>Optional[bytes]</code> <p>Optional body content as bytes (if not provided, extracted from entry)</p> <code>None</code>"}]}